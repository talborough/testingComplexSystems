#!/usr/bin/python3

""" - Status

+++ - animalFarm_02 - A test platform to do 2 things:

    -- Display how to build an interactive program that can serve as a product's
       random load and stress test facility.

    -- Present the "global data store" (gDS) concept that can be at the center
       of such a program.

    There is help text just below *or* (./animalFarm_02 --help)

    V0103 - 10/20/2025 19:20 - Fixup for case study videos.
    V0102 - 03/15/2025 21:15 - Remove silly code.
    V0101 - 01/22/2024 09:20 - Fix up for webinars. Change the name of the generated support routines.
    V0100 - 01/04/2024 07:58 - Initial version entry.
    
    Plans:
    
---

"""

#
# Consume the gDS definition file animalFarm_02.py (you must first use gDSCodeGen on animalFarm_02.dd):
#
#       ../gDS/gDSCodeGen animalFarm_02             >>>>>> Produces animalFarm_02.py

from multiprocessing import Process
from threading import Thread
from multiprocessing import Lock

import time
import sys
import os
import select
import random
import getopt


#
# Consume the schema .py file generated by gDSCodeGen if it exists and it's not out of date
#
if (not os.path.exists("./animalFarm_02.py")) or \
   (os.path.getmtime("./animalFarm_02.dd") >= os.path.getmtime("./animalFarm_02.py")):
    print ("")
    print ("./animalFarm_02.py does not exist or needs to be re-created with gDSCodeGen. Exiting.")
    print ("")
    sys.exit(1)
    
exec (open('animalFarm_02.py').read())


Help = """

####################
#
# animalFarm_02 - Help
#
####################
#
#
animalFarm_02 does two things: it illustraits the use of "gDS" to operate as a lightweight "data store", 
and it presents a simulated "test platform". For background see: "https://TestingComplexSystems.com".


The program starts by populating a gDS data store: first with farms then animals in the farms (cows and 
chickens). The user can then start independent background processes that "tend" and "raise" the animals:

    -- "tend" - The animals are looked after (cows are milked; chickens have their eggs gathered).
    
    -- "raise" - New animals are cloned from existing animals or existing animals are "sent to market" 
       (their data store rows "erased").

These background processes can be run ad-hoc or, over and over (test "runs", in test "cycles").
       
A test run executes for a certain amount of time (run time) and it stops and reconciles (checks the 
data) every so many seconds (cycle time). Both times are user specified.

Milk and eggs are gathered and tracked (two ways) and if the two counts don't match at the end of a 
cycle, the program exits with an error. The animal count and production values are tracked as:

    -- Calculated - An overall totalizer is adjusted each time the item is created or deleted by a 
       background activities.
    
    -- Observed -- The collection table amounts are calculated from separate farm table variables.

animalFarm_02 runs in one of 2 operating modes:

    -- Interactively - Here the user has a menu that gives them full control over what the program does. The display 
       is updated every 3 seconds.
       
            -- In interactive mode a menu allows the user to start and stop individual activities OR ...
            
            -- make a "test run" where the specified activities are run over and over (cycles) for a 
               given total time (run time).
       
    -- Command line - Here command line args trigger batch mode operation and specify a single run of 
       the code. For now the screen is updated every 3 seconds in batch mode just so the user can keep an 
       eye on it, but the user has no control over the run once the run starts.
       
The various menu items (interactive as menu selections / batch as Batch arguments (**) "--xx=nn") are:

    fs / ad - Set farm summary / animal detail displays

    rt - Set total run time in seconds (**)
    
    ct - Set the cycle time in seconds (**)
    
    tc, tx, rc, rx - tend / raise animal background process count (**)
    
    up - As the simulation run *animals* collect milk and eggs. When the background processes are stopped, the "up" 
         command add the *animal* production values to the *farm* totals and then the animals values get zeroed (this 
         allows "erased" animals to then be compressed out).
         
    ca - This compresses out any erased animals.
    
    va - This does the above 2 operations and then verifies the "calculated" and "observed" values match (see above).

    st - Start a test run (like batch but the screen and input stays "live").
    
    eb - End all background processes
    
    e1 - Inject an error to trip the verification

"""


class Color:

    RED = "\u001b[31m"
    GREEN = "\u001b[32m"
    YELLOW = "\u001b[33m"
    BLUE = "\u001b[34m"
    MAGENTA = "\u001b[35m"
    CYAN = "\u001b[36m"
    WHITE = "\u001b[37m"


#
# Help control concurrent access to table rows.
#
class MasterLock:

    lockObject = Lock()

    def lock():
        
        MasterLock.lockObject.acquire()
        return
        
    def unlock():
    
        MasterLock.lockObject.release()
        return


#
# The UI class houses code that gives this UI its look and feel: that starts a run "on its way", that
# monitors the run's progress, and that provides interactive operation.
#
class UI:

    # Help the user remember where they are
    lastCommand = "<none>"

    # The currently displaying screen
    displayName = "farmSummary"
    
    # The background process objects
    backgroundProcs = []
    
    # The count of the 4 possible background activities
    tcCount = 0
    rcCount = 0
    txCount = 0
    rxCount = 0
    
    # Test run attributes
    runTime = 0
    cycleTime = 0

    #
    # setUp creates counties and farms and a starting set of animals. Notice we randomize creation
    # order using spawned processes / threads. Manage concurrency with just MasterLock. Set up
    # and manage gTotalAnimalsCalculated / gTotalAnimalsObserved.
    #
    def setUp():

        # Start in interactive mode
        gStartTime[0] = time.time()
        gMakeTestRun[0] = False
    
        # Make some counties then the farms in it
        def makeACounty(countyNumber):

            # This gets all executors sleeping for random times
            time.sleep(random.uniform(0.0, 3.0))
    
            MasterLock.lock()
            countyRef = gCounty_AddARow(_Name = "County #%2.2d" % (countyNumber + 1), _RowStatus = "")
            MasterLock.unlock()

            print (f"Added {gCounty_Name[countyRef]}")
            
            threads = []
            
            for farmNumber in range(3):
                threads.append(Thread(target = makeAFarm, args = (countyRef, farmNumber)))
                threads[-1].start()
                
            for thread in threads:
                thread.join()
                
            return

        # Make a farm then all the animals in it
        def makeAFarm(countyRef, farmNumber):

            # This gets all executors sleeping for random times
            time.sleep(random.uniform(0.0, 3.0))
    
            # Add farms
            MasterLock.lock()
            
            farmRef = gFarm_AddARow(_gCounty_Ref = countyRef, _Name = "Farm #%2.2d" % (farmNumber + 1), \
                                    _RowStatus = "")
            MasterLock.unlock()
            
            print (f"Added {gFarm_Name[farmRef]} in {gCounty_Name[countyRef]}")
            
            threads = []
            
            # Add animals to the farm
            for animalNumber in range(3):
                threads.append(Thread(target = makeAnAnimal, args = (farmRef, animalNumber, "Cow")))
                threads[-1].start()
                
            for animalNumber in range(3):
                threads.append(Thread(target = makeAnAnimal, args = (farmRef, animalNumber, "Chicken")))
                threads[-1].start()
                
            for thread in threads:
                thread.join()
                
            return
            
        # Make animals
        def makeAnAnimal(farmRef, animalNumber, animalType):

            # This gets all executors sleeping for random times
            time.sleep(random.uniform(2.0, 4.0))
    
            # Add animals under lock
            MasterLock.lock()
            
            animalRef = gAnimal_AddARow(_gFarm_Ref = farmRef, _Name = "%s #%2.2d (%2.2d)" % (animalType, animalNumber + 1, farmRef), _Type = animalType, _RowStatus = "")

            print (f"Added {gAnimal_Name[animalRef]} to {gFarm_Name[farmRef]} in {gCounty_Name[gFarm_gCounty_Ref[farmRef]]}")
            
            gTotalAnimalsCalculated[0] += 1
            
            MasterLock.unlock()
            
            return
            
        processes = []
        
        # Start here with making counties on per process (and t hey will make farms and animals)
        for countyNumber in range(3):
            processes.append(Process(target = makeACounty, args = (countyNumber, )))
            processes[-1].start()
            
        for process in processes:
            process.join()
            
        # The lock isn't necessary here because we're mainline but let's follow protocol
        MasterLock.lock()
        gTotalAnimalsObserved[0] = len(gAnimal_RowStatus)
        MasterLock.unlock()
        
        return

    # One of the 2 main displays - by farm
    def displayFarmSummary():
    
        #
        # The challenge here is to produce a sorted display of items that have non-unique names for things
        #
        
        gScreenLines[0] += (" \n")
        gScreenLines[0] += ("                                   Cow  Chx  Busy   New    New   Milk   Eggs  \n")
        gScreenLines[0] += ("      County            Farm       Cnt  Cnt         Milk   Eggs  Total  Total \n")
        gScreenLines[0] += ("      ======            ====       ===  ===  ====   ====   ====  =====  ===== \n")
        gScreenLines[0] += (" \n")
        
        # Go by counties - prepare a dict of county names
        countyName2Ref = {}
        for (countyRef, countyName) in enumerate(gCounty_Name):
            countyName2Ref[countyName] = countyRef
            
        for (countyName, countyRef) in sorted(countyName2Ref.items()):

            # Go by farms (in counties) - prepare a dict of farm names in this county
            farmName2Ref = {}
            for (farmRef, farmName) in enumerate(gFarm_Name):
                if gFarm_gCounty_Ref[farmRef] == countyRef:
                    farmName2Ref[farmName] = farmRef
            
            for (farmName, farmRef) in sorted(farmName2Ref.items()):
                    
                # Go by animals (in farms)
                
                cowCount = 0
                chickenCount = 0
                inProcessingCount = 0
                
                milkPumped = 0
                eggsGathered = 0
                
                # For each un-erased animal on this farm
                for (animalRef, animalFarmRef) in enumerate(gAnimal_gFarm_Ref):
                
                    if (animalFarmRef == farmRef) and (gAnimal_RowStatus[animalRef] is not None):
                    
                        if gAnimal_Type[animalRef] == "Cow":
                            cowCount += 1
                            milkPumped += gAnimal_Produced[animalRef]
                        
                        if gAnimal_Type[animalRef] == "Chicken":
                            chickenCount += 1
                            eggsGathered += gAnimal_Produced[animalRef]
                            
                        if gAnimal_RowStatus[animalRef] != "":
                            inProcessingCount += 1

                x = y = Color.WHITE
                if inProcessingCount:
                    x = Color.RED
                    
                gScreenLines[0] += (" %15s %15s  %4d %4d  %s%4d%s %6d %6d %6d %6d \n" % (countyName, gFarm_Name[farmRef], cowCount, chickenCount, \
                                                               x, inProcessingCount, y, milkPumped, eggsGathered, \
                                                               gFarm_MilkTotal[farmRef], gFarm_EggsTotal[farmRef]))
                                                               
                countyName = ""
                
        return

    # The other display - a single character per animal ("c" or "x"), colored by animal status
    def displayAnimalDetail():
    
        out = ""
        gScreenLines[0] += (" \n")
    
        for (animalRef, animalRowStatus) in enumerate(gAnimal_RowStatus):
        
            animal = "c"
            if gAnimal_Type[animalRef] == "Chicken":
                animal = "x"
                
            x = Color.WHITE
            if animalRowStatus is None:
                x = Color.CYAN
            elif animalRowStatus != "":
                x = Color.RED
            
            out += x + animal + " "
            
            if len(out) > 100:
                gScreenLines[0] += (f" {out} \n")
                out = ""
                
        gScreenLines[0] += (f" {out} \n")
        
        gScreenLines[0] += (" \n")
        gScreenLines[0] += (f" (c) = Cows; (x) = Chickens; Count of gAnimal_Name2Ref index entries = {len(gAnimal_Name2Ref)} \n")
        gScreenLines[0] += (f" White = not active; {Color.RED}Red = active; {Color.CYAN}Cyan = erased (to be compressed out){Color.WHITE} \n")
        
        return

    # Ask the user how many background processes to run doing tending / raising work
    def getActivityCount(activityType):

        print ("")
        aCount = input(f" Enter the number of parallel {activityType} activities [def = 3]: ")
        
        if aCount == "":
            aCount = 3
        aCount = int(aCount)
        
        return (aCount)            


    # Several routines to start up background work
    def startTCs(aCount, startUp = False):
    
        for i in range(aCount):
            UI.backgroundProcs.append(Process(target = Background.tendCow, args = ()))
            if startUp:
                UI.backgroundProcs[-1].start()
                
        return


    def startRCs(aCount, startUp = False):
    
        for i in range(aCount):
            UI.backgroundProcs.append(Process(target = Background.raiseCow, args = ()))
            if startUp:
                UI.backgroundProcs[-1].start()
                
        return


    def startTXs(aCount, startUp = False):
                            
        for i in range(aCount):
            UI.backgroundProcs.append(Process(target = Background.tendChicken, args = ()))
            if startUp:
                UI.backgroundProcs[-1].start()
                
        return


    def startRXs(aCount, startUp = False):
                            
        for i in range(aCount):
            UI.backgroundProcs.append(Process(target = Background.raiseChicken, args = ()))
            if startUp:
                UI.backgroundProcs[-1].start()
                
        return


    # Get rid of erased animals (the routine is in the gDS .py file)
    # This (should) never be called with background tasks running!
    def compressAnimals():
  
        gAnimal_DeleteRows(rowStatusValueToDelete = None)

        return
        
        
    # Add observed values from each farm's total production
    def updateObserved():
    
        MasterLock.lock()
                
        # Get animal counts (compression must have been run before this)
        gTotalAnimalsObserved[0] = len(gAnimal_RowStatus)
        
        # Get total observed counts from all per-farm counts
        gTotalMilkObserved[0] = 0
        gTotalEggsObserved[0] = 0
        
        for farmRef in range(len(gFarm_RowStatus)):
            gTotalMilkObserved[0] += gFarm_MilkTotal[farmRef]
            gTotalEggsObserved[0] += gFarm_EggsTotal[farmRef]
            
        MasterLock.unlock()

        return


    # Display calculated and observed values
    def printCalculatedAndObserved():
    
        x = Color.RED
        y = Color.WHITE

        MasterLock.lock()
    
        gScreenLines[0] += (" \n")
        gScreenLines[0] += (f" {x}{gTotalAnimalsCalculated[0]}{y} animals calculated; {x}{gTotalAnimalsObserved[0]}{y} animals observed \n")
        gScreenLines[0] += (f" {x}{gTotalMilkCalculated[0]}{y} milk production calculated; {x}{gTotalMilkObserved[0]}{y} milk production observed \n")
        gScreenLines[0] += (f" {x}{gTotalEggsCalculated[0]}{y} egg production calculated; {x}{gTotalEggsObserved[0]}{y} egg production observed \n")
       
        MasterLock.unlock()

        return
      
      
    # Add "new" animal values to "total" farm values and zero animal values
    def updateProduction():
    
        for (animalRef, animalType) in enumerate(gAnimal_Type):
            if animalType == "Cow":
                gFarm_MilkTotal[gAnimal_gFarm_Ref[animalRef]] += gAnimal_Produced[animalRef]
            elif animalType == "Chicken":
                gFarm_EggsTotal[gAnimal_gFarm_Ref[animalRef]] += gAnimal_Produced[animalRef]
            gAnimal_Produced[animalRef] = 0
            
        return

    # Do all the necessary to update and verify the calculated / observed values
    # Check for running background activity BEFORE calling
    def processDataAndVerifyAll():
    
        # MUST update product totals (using possible erased animals) BEFORE compressing them away
        print ("")
        print (" Process before verification:")
        print ("")
        print ("   1) Update 'total' farm production values with 'new' values from both active and erased animals")
        UI.updateProduction()

        print ("   2) Now we can compress out erased animals")
        UI.compressAnimals()

        print ("   3) Update observed production counts with new production counts from the farms")
        UI.updateObserved()

        print ("   4) Verify animal table index (counts then values)")

        indexBad = False

        nameCount = len(gAnimal_Name)
        indexCount = len(gAnimal_Name2Ref)
        print ("")
        print (f" Name count = {Color.RED}{nameCount}{Color.WHITE}; index count = {Color.RED}{indexCount}{Color.WHITE}")
        if nameCount != indexCount:
            indexBad = True
        
        for animalRef in range(len(gAnimal_RowStatus)):
            if gAnimal_Name2Ref[gAnimal_Name[animalRef]] != animalRef:
                indexBad = True
                
        if indexBad:
            print ("")
            print (f" {Color.CYAN}The index does not match the table!!!{Color.WHITE}")
            exit(1)
                
        UI.printCalculatedAndObserved()

        print ("")
        print (" Verify totals above!")
        if gTotalAnimalsCalculated[0] != gTotalAnimalsObserved[0] or \
           gTotalMilkCalculated[0] != gTotalMilkObserved[0] or \
           gTotalEggsCalculated[0] != gTotalEggsObserved[0]:
           
            print (gScreenLines[0])

            print ("")
            print (f" {Color.RED}The counts above don't match!!!{Color.WHITE}")
            exit (1)
            
        print ("")
        print (f" {Color.GREEN}The counts above match!!!{Color.WHITE}")
                
        return

    # Used in many places to ensure we don't step on running background activities
    def someBackgroundAlive():
        
        aliveCount = 0
        for process in UI.backgroundProcs:
            if process.is_alive():
                aliveCount += 1
        return (aliveCount)


    # Process user input
    def processCommand(command):
    
        # Interactive help
        if command == "help":
        
            print (Help)
            input ("Enter <CR> to continue: ")


        # Process "start a test run" command
        elif command == "st":
        
            if gMakeTestRun[0] or UI.someBackgroundAlive():
                print ("")
                print (f"A test run / some background activities are already in progress - you must stop them first (eb)")
                time.sleep(3)
            else:

                # Awkward but understandable
                UI.tcCount = 0
                UI.rcCount = 0
                UI.txCount = 0
                UI.rxCount = 0
                
                gMakeTestRun[0] = True
                
                UI.tcCount = UI.getActivityCount("cow-tending")
                UI.rcCount = UI.getActivityCount("cow-raising")
                UI.txCount = UI.getActivityCount("chicken-tending")
                UI.rxCount = UI.getActivityCount("chicken-raising")
                
                print ("")
                aCount = input(" Enter the run time in seconds [def = 45]: ")
    
                if aCount == "":
                    aCount = 45
                UI.runTime =  int(aCount)
    
                print ("")
                aCount = input(" Enter the cycle time in seconds [def = 15]: ")
    
                if aCount == "":
                    aCount = 15
                UI.cycleTime =  int(aCount)
                
                gRunStopTime[0] = time.time() + UI.runTime
                
                UI.startACycle()
        
        # Verify all
        elif command == "va":
            if gMakeTestRun[0] or UI.someBackgroundAlive():
                print ("")
                print ("A test run / some background activities are already in progress - you must stop them first (eb)")
                time.sleep(3)
            else:
                UI.processDataAndVerifyAll()
                time.sleep(3)
            
        # Inject an error
        elif command == "e1":
            gAnimal_Produced[0] += 1

        # Set one of two displays
        elif command == "ad":
            UI.displayName = "animalDetail"
            
        elif command == "fs":
            UI.displayName = "farmSummary"
            
        # Tend cow, tend chicken etc.
        elif (not gMakeTestRun[0]) and command == "tc":
        
            gStopBackgroundProcs[0] = False

            aCount = UI.getActivityCount("cow-tending")
            UI.tcCount += aCount
            UI.startTCs(aCount = aCount, startUp = True)

        elif (not gMakeTestRun[0]) and command == "tx":
        
            gStopBackgroundProcs[0] = False
            
            aCount = UI.getActivityCount("chicken-tending")
            UI.txCount += aCount
            UI.startTXs(aCount = aCount, startUp = True)

        elif (not gMakeTestRun[0]) and command == "rc":
        
            gStopBackgroundProcs[0] = False

            aCount = UI.getActivityCount("cow-raising")
            UI.rcCount += aCount
            UI.startRCs(aCount = aCount, startUp = True)

        elif (not gMakeTestRun[0]) and command == "rx":
        
            gStopBackgroundProcs[0] = False

            aCount = UI.getActivityCount("chicken-raising")
            UI.rxCount += aCount
            UI.startRXs(aCount = aCount, startUp = True)

        # End any background work going on
        elif command == "eb":
        
            gRunStopTime[0] = 0
            gCycleStopTime[0] = 0
            
            gStopBackgroundProcs[0] = True
            
            UI.tcCount = 0
            UI.rcCount = 0
            UI.txCount = 0
            UI.rxCount = 0
            
        # Do a few things by hand for interactive users
        # Update farm production figures from animals' (should use erased animals' data first)
        elif command == "up":
        
            if gMakeTestRun[0] or UI.someBackgroundAlive():
                print ("")
                print (f"A test run / some background activities are in progress - you must stop them first (eb)")
                time.sleep(3)
            else:
                UI.updateProduction()
            
        # Compress out erased animals rows
        elif command == "ca":
        
            if gMakeTestRun[0] or UI.someBackgroundAlive():
                print ("")
                print (f"A test run / some background activities are in progress - you must stop them first (eb)")
                time.sleep(3)
            else:
                UI.compressAnimals()
            
        # Dump table rows
        elif command == "dc":
            gCounty_DumpRows()
            print ("")
            input (" Hit Enter to continue: ")
            
        elif command == "df":
            gFarm_DumpRows()
            print ("")
            input (" Hit Enter to continue: ")
            
        elif command == "da":
            gAnimal_DumpRows()
            print ("")
            input (" Hit Enter to continue: ")
            
        else:
            UI.lastCommand = ""
            print ("")
            print (f"Invalid or not currently executable command: '{command}'")
            time.sleep(2)

        return


    # Service the updating of the terminal screen
    def serviceTerminal():
    
        # Lines 1 and 2 of header
        gScreenLines[0] = "\033[H\033[J \n"
        gScreenLines[0] += (" Uptime in seconds = %d;" % \
              (time.time() - gStartTime[0]))

        # Line 3 of header
        # Figure color of speced background process counts
        x1 = x2 = x3 = x4 = x5 = x6 = y = Color.WHITE
        if UI.tcCount:
            x1 = Color.RED
        if UI.rcCount:
            x2 = Color.RED
        if UI.txCount:
            x3 = Color.RED
        if UI.rxCount:
            x4 = Color.RED

        gScreenLines[0] += (f" Background composition: Tend cow = {x1}{UI.tcCount}{y}; Raise cow = {x2}{UI.rcCount}{y}; Tend chicken = {x3}{UI.txCount}{y}; Raise chicken = {x4}{UI.rxCount}{y} \n")

        # Line 4 of header
        x = Color.RED
        y = Color.WHITE
        # If running background down in interactive "test run" mode
        if gMakeTestRun[0] and (gRunStopTime[0] == 0):
            gScreenLines[0] += (f" {x}Test run rundown{y} \n")
        # If interactive
        elif (not gMakeTestRun[0]) or (gRunStopTime[0] == 0):
            gScreenLines[0] += (f" {x}Interactive operation{y} \n")
        # Must be "test run" mode
        else:
            if {int(gCycleStopTime[0] - time.time()) > 0}:
                x5 = Color.RED
            if {int(gRunStopTime[0] - time.time()) > 0}:
                x6 = Color.RED
            batch = ""
            if gBatchMode[0]:
                batch = "Batch mode! "
            gScreenLines[0] += (f" {x}{batch}Test run{y} time left: {x6}{int(gRunStopTime[0] - time.time())}{y}; Test cycle time left: {x5}{int(gCycleStopTime[0] - time.time())}{y} \n")

        # Decide what display to show
        if UI.displayName == "farmSummary":
            UI.displayFarmSummary()
        elif UI.displayName == "animalDetail":
            UI.displayAnimalDetail()
            
        gScreenLines[0] += (" \n")
        gScreenLines[0] += (" The 3 lines below are only accurate after ((up) and (ca)) or (va) operations! \n")
        #  Update observed now because it's cheap
        UI.updateObserved()
        UI.printCalculatedAndObserved()
            
        if not gBatchMode[0]:
        
            # Update menu
            gScreenLines[0] += (" \n")
            gScreenLines[0] += (" fs / ad = Display farm summary; display animal detail \n")
            gScreenLines[0] += (" dc / df / da = Dump counties / farms / animals \n")
            
            if not gMakeTestRun[0]:
                gScreenLines[0] += (" \n")
                gScreenLines[0] += (" tc / tx / rc / rx = tend cows, chickens / raise cows, chickens \n")
                gScreenLines[0] += (" up / ca / va = Update farm production tables; Compress the gAnimal table; Verify all \n")

            gScreenLines[0] += (" st / eb = Start a test run; End all (background/test run) processing \n")
            gScreenLines[0] += (" e1 = Inject an error during a test run \n")
            gScreenLines[0] += (" help - Print help on screen \n")
            gScreenLines[0] += (" \n")
            gScreenLines[0] += (f" Last command = '{UI.lastCommand}' \n")
    
        # Handle Batch mode by starting a test run with the pre-stored command line arg values
        if gBatchMode[0] and (gRunStopTime[0] == 0):
        
            gRunStopTime[0] = time.time() + UI.runTime
            gMakeTestRun[0] = True
            UI.startACycle()
            
        # More time in Batch mode - just sleep 3 seconds per screen update
        elif gBatchMode[0]:
        
            print (gScreenLines[0])
            time.sleep(3)
            
        # Else, interactive
        elif not gBatchMode[0]:

            print (gScreenLines[0])
            print (" Type a command from the menu above then hit Enter: ")

            # Get any user input
            i, o, e = select.select([sys.stdin], [], [], 3)
            
            # If some input
            if i:
            
                command = sys.stdin.readline().strip()
                
                UI.lastCommand = command

                # Process user input
                UI.processCommand(command)

        return
        

    # Start / continue cycles
    def startACycle():
    
        # Set so started background tasks can/do run
        gCycleStopTime[0] = time.time() + UI.cycleTime
        gStopBackgroundProcs[0] = False
        UI.backgroundProcs = []

        UI.startTCs(aCount = UI.tcCount, startUp = True)
        UI.startRCs(aCount = UI.rcCount, startUp = True)
        UI.startTXs(aCount = UI.txCount, startUp = True)
        UI.startRXs(aCount = UI.rxCount, startUp = True)

        return
        

    def getBatchArgs():
    
        try:
            opts, args = getopt.getopt(sys.argv[1:], "h", ["help",
                                                           "rt=",
                                                           "ct=",
                                                           "tc=",
                                                           "tx=",
                                                           "rc=",
                                                           "rx="])
        except getopt.GetoptError as err:
            print(err)
            print (Help)
            sys.exit(2)

        for i in range(0, len(opts)):
            if opts[i] in ("-h", "--help"):
                print (Help)
                exit(0)

            elif opts[i][0] == ("--rt"):
                UI.runTime = int(opts[i][1])

            elif opts[i][0] == ("--ct"):
                UI.cycleTime = int(opts[i][1])

            elif opts[i][0] == ("--tc"):
                UI.tcCount = int(opts[i][1])

            elif opts[i][0] == ("--tx"):
                UI.txCount = int(opts[i][1])

            elif opts[i][0] == ("--rc"):
                UI.rcCount = int(opts[i][1])

            elif opts[i][0] == ("--rx"):
                UI.rxCount = int(opts[i][1])

            else:
                print (Help)
                sys.exit(0)

        return


    # Drive a single run from Batch arguments
    def coreBatchLogic():
    
        # Always update the screen until end of run (exits below)
        while True:

            # While some background activity - run it down
            while UI.someBackgroundAlive():
            
                # Post stop background if in a cycle and time to stop cycle
                if time.time() > gCycleStopTime[0]:
                    gStopBackgroundProcs[0] = True

                # Update screen and process any user input (blend screen output for now)
                UI.serviceTerminal()
                
            UI.serviceTerminal()

            # If running test cycles and done running background - it's end of cycle
            if not UI.someBackgroundAlive():

                UI.processDataAndVerifyAll()
                time.sleep(3)
            
                # If more cycles to run start them else back to interactive or end of batch
                if time.time() < gRunStopTime[0]:
                    UI.startACycle()
                else:
                    # End of Batch run
                    UI.serviceTerminal()
                    print (" Done!")
                    print ("")
                    exit (0)

        # End of Batch run processing goes here


    # Watch/control what's going on from displays rendered on terminals (only the main terminal in coded for now)
    def coreInteractiveLogic():
    
        # Always update the screen - need a Ctrl-C to exit (the desired "MO" for now)
        while True:

            # Main service loop
            # While in interactive mode (not making test run) or while we need to wait for background activities to stop
            while (not gMakeTestRun[0]) or UI.someBackgroundAlive():
            
                # Post stop background if in a cycle and time to stop cycle
                if gMakeTestRun[0]:
                    if time.time() > gCycleStopTime[0]:
                        gStopBackgroundProcs[0] = True

                # Update screen and process any user input
                UI.serviceTerminal()

            # If running test cycles and done running background - it's end of cycle so...
            if gMakeTestRun[0] and (not UI.someBackgroundAlive()):

                # Process end-of-cycle and verify
                UI.processDataAndVerifyAll()
                time.sleep(3)
            
                # If more cycles to run start them else back to interactive or end of batch
                if time.time() < gRunStopTime[0]:
                    UI.startACycle()
                else:
                    gMakeTestRun[0] = False
                    UI.tcCount = 0
                    UI.rcCount = 0
                    UI.txCount = 0
                    UI.rxCount = 0
                    
        # End of processing goes here (we never exit from "while" above)


# Background workers
#
# gAnimal_RowStatus values:
#
#   ""      - Animal is available for use
#   "xxx"   - Animal is in use for "xxx"
#   None    - Animal is erased
#
class Background:

    # Allocate any animal of the given type with RowStatus = ""
    def allocateAnAnimal(animalType, rowStatus):
    
        animalRefToReturn = None
    
        while (not gStopBackgroundProcs[0]) and (animalRefToReturn is None):
        
            # Make a "soft" loop
            time.sleep(0.2)

            MasterLock.lock()

            randomAnimalRef = random.randrange(0, len(gAnimal_RowStatus))
            
            # If a free animal of needed type
            if (gAnimal_Type[randomAnimalRef] == animalType) and (gAnimal_RowStatus[randomAnimalRef] == ""):

                # Lock the row
                gAnimal_RowStatus[randomAnimalRef] = rowStatus
                animalRefToReturn = randomAnimalRef

            MasterLock.unlock()

        return (animalRefToReturn)

        
    # Milk the cow...
    def tendCow():

        while not gStopBackgroundProcs[0]:

            # Locate a random, target cow on a farm
            animalRef = Background.allocateAnAnimal("Cow", "Tending")
            
            if animalRef is not None:
            
                MasterLock.lock()

                # Figure amount to milk
                milkAdjust = int(random.uniform(4.0, 6.0))
                gAnimal_Produced[animalRef] += milkAdjust
                gTotalMilkCalculated[0] += milkAdjust
                
                MasterLock.unlock()

                # Artifically extend processing time before releasing the row lock so the animal looks "busy"
                time.sleep(1)

                gAnimal_RowStatus[animalRef] = ""

            # Make a "soft" loop
            time.sleep(1)
            
        return


    # Create / erase a cow (net ~70/30)
    def raiseCow():
    
        while not gStopBackgroundProcs[0]:
        
            # Locate a random, target cow on a farm
            animalRef = Background.allocateAnAnimal("Cow", "Raising")
            
            if animalRef is not None:
            
                MasterLock.lock()
                
                # If to create a new cow on the same farm
                if random.randrange(0, 10) > 3:
                    # Create a new, available cow on the same farm
                    gAnimal_AddARow(_Type = "Cow", _Name = f"Cow #{time.time()}", \
                                             _gFarm_Ref = gAnimal_gFarm_Ref[animalRef], _RowStatus = "")
                    # Free random target cow
                    newRowStatus = ""
                    cowAdjust = +1
                # Else send cow to processor
                else:
                    # Erase the random target cow later
                    newRowStatus = None
                    cowAdjust = -1
                    
                # Adjust the animal accumulator +/-
                gTotalAnimalsCalculated[0] += cowAdjust
                
                MasterLock.unlock()

                # Artifically extend processing time before releasing the row lock so the animal looks "busy"
                time.sleep(1)
                
                gAnimal_RowStatus[animalRef] = newRowStatus

            # Make a "soft" loop
            time.sleep(1)
            
        return


    # Gather chicken eggs
    def tendChicken():
    
        while not gStopBackgroundProcs[0]:
        
            # Locate a random, target chicken on a farm
            animalRef = Background.allocateAnAnimal("Chicken", "Tending")
            
            if animalRef is not None:
            
                MasterLock.lock()

                # Figure amount of eggs to collect
                eggsAdjust = int(random.uniform(1.0, 2.0))
                gAnimal_Produced[animalRef] += eggsAdjust
                gTotalEggsCalculated[0] += eggsAdjust

                MasterLock.unlock()
                
                # Artifically extend processing time before releasing the row lock so the animal looks "busy"
                time.sleep(1)

                gAnimal_RowStatus[animalRef] = ""

            # Make a "soft" loop
            time.sleep(1)
            
        return


    # Create / erase a chicken (net ~70/30)
    def raiseChicken():
    
        while not gStopBackgroundProcs[0]:
        
            # Locate a random, target chicken on a farm
            animalRef = Background.allocateAnAnimal("Chicken", "Raising")
            
            if animalRef is not None:
            
                MasterLock.lock()

                # If to create a new chicken on the same farm
                if random.randrange(0, 10) > 3:
                    # Create a new, available chicken on the same farm
                    gAnimal_AddARow(_Type = "Chicken", _Name = f"Chicken #{time.time()}", \
                                             _gFarm_Ref = gAnimal_gFarm_Ref[animalRef], _RowStatus = "")
                    # Release the random target chicken
                    newRowStatus = ""
                    chickenAdjust = +1
                # Else send chicken to processor
                else:
                    # Mark the random target chicken for erase later
                    newRowStatus = None
                    chickenAdjust = -1

                # Adjust the animal accumulator +/-
                gTotalAnimalsCalculated[0] += chickenAdjust
                
                MasterLock.unlock()

                # Artifically extend processing time before releasing the row lock so the animal looks "busy"
                time.sleep(1)
                
                gAnimal_RowStatus[animalRef] = newRowStatus

            # Make a "soft" loop
            time.sleep(1)
            
        return
        
        
#
# Main code
#
if __name__ == "__main__":

    # Handle batch mode
    gBatchMode[0] = False
    if len(sys.argv) > 1:
        UI.getBatchArgs()
        gBatchMode[0] = True

    # Start with this display on the screen
    displayName = "farmSummary"
    
    print ("")
    print ("Create some data to work with in random order over the next 10 seconds or so...")
    print ("")
    time.sleep(1)
    
    # Set up the global DB for subsequent operation
    UI.setUp()
    
    # Make a major decision on what code to execute based on interactive or batch mode 
    print ("")
    if gBatchMode[0]:
        print ("Start one batch run")
        time.sleep(2)
        UI.coreBatchLogic()
    else:
        print ("Start screen refresh / interactive command input mode...")
        # Start the endless cycle running
        time.sleep(2)
        UI.coreInteractiveLogic()
        
    # No return from either branch above!!