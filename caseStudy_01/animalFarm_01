#!/usr/bin/python3

""" - Status

+++ - animalFarm_01 - Explore gDS

    V0100 - 01/04/2024 07:48 - Initial version entry.
    
    Plans:
    
        Update to support webinars.
    
        At some point align (change) the names of the routines generated by gDSCodeGen.
        Note this will break all existing code until the names are adjusted.

---

"""

from multiprocessing import Process
from threading import Thread
from multiprocessing import Lock

import time
import random
import os
import sys

#
# Consume the gDS include file generated by gDSCodeGen if it exists and it's not out of date
#
if (not os.path.exists("./animalFarm_01.py")) or \
   (os.path.getmtime("./animalFarm_01.dd") >= os.path.getmtime("./animalFarm_01.py")):
    print ("")
    print ("./animalFarm_01.py does not exist or needs to be re-created using gDSCodeGen. Exiting.")
    print ("")
    sys.exit(1)
    
exec (open('animalFarm_01.py').read())


#
# Help control concurrent access to table rows.
#
class MasterLock:

    lockObject = Lock()

    def lock():
        
        MasterLock.lockObject.acquire()
        return
        
    def unlock():
    
        MasterLock.lockObject.release()
        return


#
# This supports extracting in-line text blocks at run time.
# It's good for templates and "help" blocks.
#
class InLineText:

    codeLines = []

    def getCodeLines():
    
        InLineText.codeLines = open(sys.argv[0], "r").read().splitlines()


    def getText(tag, substitutionList = []):

        lineRef = 0
        harvestingText = False
        harvestedText = ''

        while lineRef <= len(InLineText.codeLines):

            line = InLineText.codeLines[lineRef]
            lineRef += 1

            if (not harvestingText) and ('""" - ' in line):
                indent = line.find('"""')
                line = line[indent:]
                line = line.replace('""" - ', "")
                if line == tag:
                    harvestingText = True
                    
            elif (not harvestingText) and (lineRef == len(InLineText.codeLines)):
                print ("Can not find in-line text tag '%s'" % (tag))
                x = 1/0

            elif harvestingText and ('"""' in line):
                return (harvestedText % (substitutionList))
                
            elif harvestingText:
                harvestedText += line[indent:] + "\n"


#
# Called by many activities to add (1) animal row to a farm under lock
#
def addOneAnimal(farmRef, animalType, animalNumber):

    # Called by each spawned process, this code gets them all running at random times
    # over a 2 to 8 second interval
    time.sleep(random.uniform(2.0, 8.0))

    tempNumber = "%2.2d" % (animalNumber)
    
    # Add this animal under lock
    MasterLock.lock()
    
    animalRef = gAnimal_AddARow(_Type = animalType, _Name = f"{animalType} #{tempNumber}", \
                                _gFarm_Ref = farmRef, _RowStatus = "")
                                
    MasterLock.unlock()

    print (f"Added a {animalType} to {gFarm_Name[farmRef]}")


##################
# Main - Start by creating the counties and farms statically in mainline code
##################

if __name__ == "__main__":

    # Display this program's status to the user
    InLineText.getCodeLines()
    #print (InLineText.getText("Status"))

    # No need to lock here!

    # Start with 2 counties
    countyRefA = gCounty_AddARow(_Name = "County A")
    countyRefB = gCounty_AddARow(_Name = "County B")

    # County A has 1 farm and County B has 2 farms
    farmRefA = gFarm_AddARow(_Name = "Farm A", _gCounty_Ref = countyRefA)

    farmRefB = gFarm_AddARow(_Name = "Farm B", _gCounty_Ref = countyRefB)

    farmRefC = gFarm_AddARow(_Name = "Farm C", _gCounty_Ref = countyRefB)
    
    print ("")
    print ("We just added 2 counties and 3 farms")


    #
    # Add some animals using a bunch of random activities
    #

    print ("")
    input ("Hit Enter to add animals randomly: ")

    activities = []

    for i in range(3):
        activities.append(Process(target = addOneAnimal, args = (farmRefA, "Cow", i+1)))
        activities[-1].start()
        activities.append(Process(target = addOneAnimal, args = (farmRefB, "Cow", i+1)))
        activities[-1].start()
        activities.append(Process(target = addOneAnimal, args = (farmRefC, "Cow", i+1)))
        activities[-1].start()
        
    for i in range(10):
        activities.append(Thread(target = addOneAnimal, args = (farmRefA, "Chicken", i+1)))
        activities[-1].start()
        activities.append(Thread(target = addOneAnimal, args = (farmRefB, "Chicken", i+1)))
        activities[-1].start()
        activities.append(Thread(target = addOneAnimal, args = (farmRefC, "Chicken", i+1)))
        activities[-1].start()
        

    print ("")
    print (f"Started {len(activities)} activities...")
        
    print ("")
    print (f"Waiting for {len(activities)} activities to run randomly and complete...")
    print ("")
        
    # Wait for all the activities to run (randomly) and complete
    for aProcess in activities:
        aProcess.join()
        

    print ("")
    print ("Done with adding animals!")
    print ("")

    # Dump all the tables
    print ("")
    input ("Hit Enter to dump Counties: ")
    print ("")
    gCounty_DumpTable()
    print ("")
    input ("Hit Enter to dump Farms: ")
    print ("")
    gFarm_DumpTable()
    print ("")
    input ("Hit Enter to dump Animals: ")
    print ("")
    gAnimal_DumpTable()

    print ("")
    input ("Hit Enter to print information about chickens in County B: ")
    print ("")
 
    # Criteria to print by
    animalTypeToPrint = "Chicken"
    countyNameToPrint = "County B"
    
    tempList = []

    # Get Ref of county to print
    countyRef = gCounty_Name2Ref[countyNameToPrint]
    
    # For all animals (Note - all concurrent activity is over - iterate on any column)
    for (animalRef, animalType) in enumerate(gAnimal_Type):
        # If correct animal type
        if animalType == animalTypeToPrint:
        
            # Get an intermediate value
            farmRef = gAnimal_gFarm_Ref[animalRef]
            # If the farm is in the right county
            if gFarm_gCounty_Ref[farmRef] == countyRef:
                # Append a line about the county / farm / animal
                tempList.append(f"County '{gCounty_Name[countyRef]}', farm '{gFarm_Name[farmRef]}' has animal '{gAnimal_Name[animalRef]}'")
              
    # Sort the resulting list and print it
    print ("")
    tempList.sort()
    for line in tempList:
        print (line)
        
    print ("")
    
    # Interactively print details of a given animal
    inStr = "x"
    while inStr:
        print ("")
        inStr = input ("Enter a value for animalRef [def = stop]: ")
        if inStr:
            animalRef = int(inStr)
            print ("")
            print ("animalRef   = ", animalRef)
            print ("Animal name = ", gAnimal_Name[animalRef])
            print ("Farm name   = ", gFarm_Name[gAnimal_gFarm_Ref[animalRef]])
            print ("County name = ", gCounty_Name[gFarm_gCounty_Ref[gAnimal_gFarm_Ref[animalRef]]])