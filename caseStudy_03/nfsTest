#!/usr/bin/python3

# Remove exp
# Manage host if server / client

#
# nfsTest - An interactive "test platform" to run / test "NFS" on a number of Linux hosts.
#
# This creates / uses nfsTest.conf; The file is generated automatically if needed and it has
# more documentation in it. Its template is in the code below (class Platform).
#
# There is help text at the bottom of this file for the user *or* (./nfsTest --help)
#
# This consumea the gDS definition file nfsTest.py (you must first use gDSCodeGen on nfsTest.dd):
#
#       ../gDS/gDSCodeGen nfsTest             >>>>>> gDSCodeGen uses nfsTest.dd to produce nfsTest.py
#
# Note that the below is not an OO implementation.
#

from multiprocessing import Process
import threading
from threading import Thread
from multiprocessing import Lock

import paramiko
import logging

import time
import sys
import os
import select
import random
import getopt


#
# Consume the gDS include file generated by gDSCodeGen if it exists and it's not out of date
#
if (not os.path.exists("./nfsTest.py")) or \
   (os.path.getmtime("./nfsTest.dd") >= os.path.getmtime("./nfsTest.py")):
    print ("")
    print ("./nfsTest.py does not exist or needs to be re-created with gDSCodeGen. Exiting.")
    print ("")
    sys.exit(1)
    
exec (open('nfsTest.py').read())


#
# Help control concurrent access to table rows.
#
class MasterLock:

    lockObject = Lock()

    def lock():
        
        MasterLock.lockObject.acquire()
        return
        
    def unlock():
    
        MasterLock.lockObject.release()
        return


#
# This supports extracting in-line text blocks at run time.
# It's good for templates and "help" blocks.
#
class InLineText:

    codeLines = []

    def getCodeLines():
    
        InLineText.codeLines = open(sys.argv[0], "r").read().splitlines()


    def getText(tag, substitutionList = []):

        lineRef = 0
        harvestingText = False
        harvestedText = ''

        while lineRef <= len(InLineText.codeLines):

            line = InLineText.codeLines[lineRef]
            lineRef += 1

            if (not harvestingText) and ('""" - ' in line):
                indent = line.find('"""')
                line = line[indent:]
                line = line.replace('""" - ', "")
                if line == tag:
                    harvestingText = True
                    
            elif (not harvestingText) and (lineRef == len(InLineText.codeLines)):
                print ("Can not find in-line text tag '%s'" % (tag))
                x = 1/0

            elif harvestingText and ('"""' in line):
                return (harvestedText % (substitutionList))
                
            elif harvestingText:
                harvestedText += line[indent:] + "\n"


#
# Screen color codes
# 
class Color:

    RED = "\u001b[31m"
    GREEN = "\u001b[32m"
    YELLOW = "\u001b[33m"
    BLUE = "\u001b[34m"
    MAGENTA = "\u001b[35m"
    CYAN = "\u001b[36m"
    WHITE = "\u001b[37m"


#
# This code supports communication between the Control Host (the host this code runs 
# on) and the Test Hosts using Paramiko (using ssh).
#
# Note that the code in the state machines that performs command-line activity (make 
# directories; mount file systems) does not use this code (see the Configurator class).
#
# This code is only uaed to provide functionality *before* a test run and at this time
# is *not* used once a test run has started.
#
class HostComm:

    # This list of Paramiko connections parallels the gDS table gHost.
    # Element [0] is the localhost.
    hostConnections = []

    # Set up HostComm.hostConnections[hostRef] instances for the hostRef passed in.
    # This elaborate code is used only once; the "reconnectToHosts" routine is used after
    # a host is rebooted by the cleanup routine "cleanall".
    def addAHostConnection(hostRef):
    
        # Check that the 2 host lists are in sync
        if len(HostComm.hostConnections) != hostRef:
            print ("")
            print ("Programming error - host lists are not in sync - dumping call stack")
            x = 1/0

        try:

            HostComm.hostConnections.append(paramiko.client.SSHClient())
            HostComm.hostConnections[hostRef].set_missing_host_key_policy(paramiko.AutoAddPolicy())
            HostComm.hostConnections[hostRef].connect(gHost_Identifier[hostRef], username = gUsername[0], password = gPassword[0])
            
            # Get the IP and hostname of the host and set them in the gDS gHost table
            (i, o, e) = HostComm.executeOnOneHost(hostRef, "hostname -I")
            gHost_IP[hostRef] = o.read().decode().strip()
            (i, o, e) = HostComm.executeOnOneHost(hostRef, "hostname")
            gHost_Hostname[hostRef] = o.read().decode().strip()
            
            gHost_Name[hostRef] = f"host #{hostRef}"
            
            x = f"Create a paramiko ssh connection to {gHost_Name[hostRef]} / {gHost_Identifier[hostRef]} / {gHost_IP[hostRef]} / {gHost_Role[hostRef]} / {gHost_Hostname[hostRef]}"
            print (x)
            logging.info(x)

        except Exception as e:
        
            print ("")
            print (e)
            logging.info(f"{e}")
            print ("Check that the ssh server is installed and running (see nfsTest.conf file for directions)")
            print ("")
            sys.exit(1)
                
        return
        
    # Reconnect any hosts rebooting during a "cleanall" command
    def reconnectRebootingHosts():

        # Look at all test hosts
        for hostRef in range(1, len(gHost_RowStatus)):
            
            # If no active host connection
            tempConnection = None
            while HostComm.hostConnections[hostRef] is None:
        
                print (f" Try to reconnect to {gHost_Name[hostRef]}")
            
                try:

                    tempConnection = paramiko.client.SSHClient()
                    tempConnection.set_missing_host_key_policy(paramiko.AutoAddPolicy())
                    tempConnection.connect(gHost_IP[hostRef], username = gUsername[0], password = gPassword[0])
                    
                    HostComm.hostConnections[hostRef] = tempConnection
                    print (f" Connected to {gHost_Name[hostRef]}")
                    time.sleep(1)

                except Exception as e:
                
                    time.sleep(0.5)
                
    def putFile (hostRef, src, dest):
 
        ftp_client = HostComm.hostConnections[hostRef].open_sftp()
        ftp_client.put(src, dest)
        ftp_client.close()
        
        return

    def getFile (hostRef, src, dest):
 
        ftp_client = HostComm.hostConnections[hostRef].open_sftp()
        ftp_client.get(src, dest)
        ftp_client.close()
        
        return

    # Execute a command on a host and return result of "(i, o, e)"
    def executeOnOneHost(hostRef, command):
    
        return HostComm.hostConnections[hostRef].exec_command(command)

    # Execute a command on a host with a wait and return result of "(i, o, e)"
    def executeOnOneHostWithWait(hostRef, command):
    
        time.sleep(0.2)
    
        return HostComm.hostConnections[hostRef].exec_command(command)

    # Execute a command on a host and return result of "(i, o, e)" unless the command failed
    def executeOnOneHostWithCheck(hostRef, command):
    
        (i, o, e) = HostComm.hostConnections[hostRef].exec_command(command)

        retcode = o.channel.recv_exit_status()
        
        if retcode:
        
            print ("")
            print (f"retcode = {retcode}")
            print ("")
            print (f"Host = #{hostRef}")
            print ("")
            print (f"Command = {command}")
            print ("")
            print (o.read().decode())
            print ("")
            print (f"stderr = {e.read().decode()}")
            print ("")
            print (f"retcode = {retcode}")
            print ("")
            print (f"Output above from {gHost_Name[hostRef]} / {gHost_Identifier[hostRef]} / {gHost_IP[hostRef]} / {gHost_Hostname[hostRef]}")
            print ("")
            
            sys.exit(1)
            
        return (i, o, e)
        

    # Get a list hosts to operate on from user input
    def getHostRefList(prompt, processControlHost):
    
        startRange = 1
        if processControlHost:
            startRange = 0
    
        print ("")
        for hostRef in range(startRange, len(gHost_RowStatus)):
        
            print (" %d) - %20s %20s %20s" % (hostRef, gHost_Identifier[hostRef], gHost_IP[hostRef], gHost_Hostname[hostRef]))
            
        print ("")
        if processControlHost:
            print (" 'all' = all; 'test' = all but '0'; or, numbers separated by whitespace")
        else:
            print (" 'test' = all but '0'; or, numbers separated by whitespace")
        print ("")
        
        selection = input(prompt)
        
        hostRefList = []
        if "all" in selection:
            hostRefList = range(0, len(gHost_RowStatus))
        elif "test" in selection:
            hostRefList = range(1, len(gHost_RowStatus))
        else:
            selection = selection.split()
            for string in selection:
                hostRefList.append(int(string))
                
        if (not processControlHost) and (0 in hostRefList):
        
            print ("")
            print ("This operation can not be performed on the Control host (#0)")
            print ("")
            hostRefList = []
            
        return (hostRefList)


#
# General-purpose test platform-related activities
#
class Platform:

    #
    # The nfsTest.conf file template
    #
    
    """ - nfsTest.conf
    #
    # nfsTest.conf - Define what's needed to get the nfsTest "test platform" up and running.
    #
    
    # Hint: When creating the necessary VMs put consecutive numbers at the end of the VM names in 
    # the hypervisor so the VM data files can be identified and deleted by hand if 
    # necessary (some hypervisors don't automatically delete VM data files when deleting the VM). 
    # Use the same number when specifying the 'hostname' so it shows up in the command line.

    # Next, when creating and setting up each of the control and test hosts, use the same privileged
    # username / password pair for all the systems. Doing it this way doesn't require ssh keys.
    
    # Finally, the ssh server package must be installed (by hand) on the control host and each of the test 
    # hosts systems defined below. After that we will be able to do everything else with nfsTest. To do the ssh 
    # install on each host:
    #
    #   sudo apt update                                 # Update the install libraries
    #   sudo apt install openssh-server                 # Install and start the ssh server
    #
    #   sudo systemctl status ssh                       # Show the status of the ssh server if necessary
    #
    # Provide (below) the username and password for all activities to use on the control host and test hosts.
    #
    
    username = <username with the sudo priv to be used accessing *all* host systems>
    password = <password to go with the above username>
    
    # Provide the server and client counts
    
    serverCount = 1
    clientCount = 2
    
    # Provide the IP address or resolvable DNS name of the test hosts:
    
    testhostIdentifier = <resolvable host name or ip #1>
    testhostIdentifier = <resolvable host name or ip #2>
    testhostIdentifier = <resolvable host name or ip #3>
    
    # These control the size and shape of the configuration being tested.

    exportFSPerHost = 3
    fsUserPerImportFS = 3

    # These define the rate at which the 'activator' forces state machine ransitions
    
    secondsPerStateTransition = 1
    transitionsPerHost = 1
    transitionsPerExportFS = 3
    transitionsPerImportFS = 10
    transitionsPerFSUser = 30
    
    """

    #
    # Get the ball rolling by creating or processing the nfsTest.conf file
    #
    def processConfFile():
    
        # Save here until we set up all gHosts below in this method
        serverCount = None
        clientCount = None
    
        # Create conf file if there is none then exit
        if not os.path.exists("nfsTest.conf"):
        
            fileDesc = open("nfsTest.conf", "w")
            fileDesc.write(InLineText.getText("nfsTest.conf"))
            fileDesc.close()
            print ("")
            print ("********************************************************")
            print ("We have just written the 'nfsTest.conf' file in the default directory")
            print ("where you can read and edit it.")
            print ("********************************************************")
            print ("")
            sys.exit(0)
        
        # Conf file is here so let's process it
        
        # Make the control host (localhost) hostRef = 0
        logging.info("Add Control gHost row")
        gHost_AddARow(_Identifier = "localhost", _IP = "localhost", _Role = "Control", _State = "")
                
        confLines = open("nfsTest.conf", "r").read().splitlines()
        
        lineIndex = 0

        while lineIndex < len(confLines):
        
            # Get next line
            line = confLines[lineIndex]
        
            # Split off any comment
            if "#" in line:
                (line, dummy) = line.split("#", 1)
                
            # If something left it's hopefully "key = value"
            if line != "":
                
                # Split what's left by whitespace
                lineBits = line.split()
                
                if (len(lineBits) != 3) or (lineBits[1] != "="):
                    print ("")
                    print (f"Bad line in nfsTest.conf file at line {lineIndex + 1}")
                    print ("")
                    print (f"Line = {confLines[lineIndex]}")
                    print ("")
                    sys.exit(1)
                    
                # Set common username
                if lineBits[0] == "username":
                    gUsername[0] = lineBits[2]
                
                # Set common password
                elif lineBits[0] == "password":
                    gPassword[0] = lineBits[2]
                
                # Add another host to the list
                elif lineBits[0] == "testhostIdentifier":
                
                    # If we still need hosts
                    if len(gHost_RowStatus) < (serverCount + clientCount + 1):
                
                        # Add a row; roles are set below after parsing all of the nfsTest.conf file
                        gHost_AddARow(_Identifier = lineBits[2])
                        logging.info(f"Adding a gHost row for {lineBits[2]}")
                        
                    else:
                    
                        print ("")
                        print (f"Ignoring extra 'testhostIdentifier' {lineBits[2]} line")

                elif lineBits[0] == "serverCount":
                    serverCount = int(lineBits[2])
                    
                elif lineBits[0] == "clientCount":
                    clientCount = int(lineBits[2])

                elif lineBits[0] == "exportFSPerHost":
                    Configurator.exportFSPerHost = int(lineBits[2])

                elif lineBits[0] == "fsUserPerImportFS":
                    Configurator.fsUserPerImportFS = int(lineBits[2])
                    
                elif lineBits[0] == "secondsPerStateTransition":
                    Configurator.secondsPerStateTransition = int(lineBits[2])
                    
                elif lineBits[0] == "transitionsPerHost":
                    Configurator.transitionsPerHost = int(lineBits[2])
                    
                elif lineBits[0] == "transitionsPerExportFS":
                    Configurator.transitionsPerExportFS = int(lineBits[2])
                    
                elif lineBits[0] == "transitionsPerImportFS":
                    Configurator.transitionsPerImportFS = int(lineBits[2])
                    
                elif lineBits[0] == "transitionsPerFSUser":
                    Configurator.transitionsPerFSUser = int(lineBits[2])
                    
                else:
                
                    print ("")
                    print (f"Unknown keyword {lineBits[0]} in nfsTest.conf at line {lineIndex + 1}. Exiting.")
                    print ("")
                    sys.exit(1)                    
                    
            # Bump line pointer
            lineIndex += 1
            
        # The contrl gHost row has been made above; set server and client host roles
        
        # Make sure we have enough hosts to satisfy the server and client counts in the nfsTest.conf file
        if (serverCount + clientCount + 1) > len(gHost_RowStatus):
            print ("")
            print (" The nfsTest.conf file doesn't specify enough hosts to fit the server and client counts also specified in it.")
            print (" Exiting.")
            print ("")
            sys.exit(1)
        
        hostRef = 1
        for i in range(serverCount):
            gHost_Role[hostRef] = "Server"
            gHost_State[hostRef] = "Inactive"
            hostRef += 1

        for i in range(clientCount):
            gHost_Role[hostRef] = "Client"
            gHost_State[hostRef] = "Inactive"
            hostRef += 1

        return

    # Ping out to all hosts from the Control / localhost
    def pingAllFromLocalhost():
    
        print ("")
        
        for hostRef in range(0, len(gHost_RowStatus)):

            print (f"Ping from 'localhost' to {gHost_Identifier[hostRef]}")
            (i, o, e) = HostComm.executeOnOneHostWithCheck(hostRef = 0, command = f"ping {gHost_Identifier[hostRef]} -c 1")
            
        return

    #
    # Put the necessary software on any host.
    #
    # !! Reload NFS server !!
    """ - Package installs
    
    sudo -S apt -y update
    sudo -S apt -y install python3-pip
    sudo -S pip3 install numpy
    sudo -S apt -y install sshpass
    sudo -S apt -y install nfs-kernel-server
    sudo -S systemctl restart nfs-kernel-server
    sudo -S systemctl status ssh
    
    """

    """ - File copies
    
    appendALine
    removeALine
    ioEngine
    
    """
    
    #
    # Load necessary packages and copy necessary files onto the test host(s)
    #
    def loadSWOnTestHosts():
    
        # Get the lists above
        packageLoadList = InLineText.getText("Package installs").splitlines()
        fileCopyList = InLineText.getText("File copies").splitlines()
        
        hostRefList = HostComm.getHostRefList("Enter the test hosts to load the necessary pagkages and files onto: ", processControlHost = False)
            
        if len(hostRefList):

            print ("")
            
            for hostRef in hostRefList:

                for command in packageLoadList:
                
                    if command:
                
                        command = f"echo {gPassword[0]} | {command}"
                    
                        print (f"Execute '{command}' on test {gHost_Name[hostRef]}")
                        (i, o, e) = HostComm.executeOnOneHostWithCheck(hostRef, command)

                print ("")
            
                # Do file copies
                for file in fileCopyList:
                
                    if file:
                
                        print (f"Copy ./{file} to test {gHost_Name[hostRef]} and make it executable")
                        HostComm.putFile(hostRef, f"./{file}", f"./{file}")
                        (i, o, e) = HostComm.executeOnOneHostWithCheck(hostRef, f"chmod 0755 ./{file}")
                            
                print ("")

        print ("")
        input (" Hit Enter to continue: ")

        return


#
# The UI class houses code that gives the UI its look and feel, that starts a run "on its way", that
# monitors the run's progress, and that services interactive and batch operation.
#
class UI:

    # Track firt execution so we can ask to "cleanall"
    firstTime = True

    # Help the user remember where they are
    lastCommand = "<none>"

    # The currently displaying screen (we only have one)
    displayName = "configuratorStates"
    
    # 
    # Clean the nfs test hosts entirely from wthe artifacts found on them
    #
    def cleanAll():
    
        def cleanIt():
    
            #
            # Stop and clean up nfsTest artifacts
            # Do not use any gDS entries
            # Use only artifacts found on the hosts
            # We can clean out the related gDS entries after if needed
            #
            # Kill any processes using the client mount points so the unmounts work
            #
            for hostRef in range(1, len(gHost_RowStatus)):
                (i, o, e) = HostComm.executeOnOneHostWithWait(hostRef, \
                        f"echo {gPassword[0]} | sudo -S lsof -N | grep 'nfsTest\|ioEngine'")
                lsofLines = o.read().decode().splitlines()
                for lsofLine in lsofLines:
                    process = lsofLine.split()[0]
                    pid = lsofLine.split()[1]
                    mntPoint = lsofLine.split()[-2]
                    print (f" Kill process '{process}' / '{pid}' using '{mntPoint}' on {gHost_Name[hostRef]}")
                    HostComm.executeOnOneHostWithWait(hostRef, \
                        f"echo {gPassword[0]} | sudo -S kill -9 {pid}")
            #
            # Unmount all nfsTest client shares on all hosts
            #
            for hostRef in range(1, len(gHost_RowStatus)):
                (i, o, e) = HostComm.executeOnOneHostWithWait(hostRef, "df")
                dfLines = o.read().decode().splitlines()
                for dfLine in dfLines:
                    if "nfsTest" in dfLine:
                        dfMountpoint = dfLine.split()[-1]
                        print (f" Unmount '{dfMountpoint}' on {gHost_Name[hostRef]}")
                        HostComm.executeOnOneHostWithWait(hostRef, \
                            f"echo {gPassword[0]} | sudo -S umount {dfMountpoint}")
                print (f" Clean out '/etc/fstab' on {gHost_Name[hostRef]}")
                HostComm.executeOnOneHostWithWait(hostRef, \
                    f"echo {gPassword[0]} | sudo -S ./removeALine /etc/fstab nfsTest")
                print (f" Clean out '/etc/ioEngine/* on {gHost_Name[hostRef]}")
                HostComm.executeOnOneHostWithWait(hostRef, \
                    f"echo {gPassword[0]} | sudo -S rm -rf /var/ioEngine")
                    
            # Un-export all nfsTest shares, restart the servers and delete the shared directories
            for hostRef in range(1, len(gHost_RowStatus)):
                print (f" Clean '/etc/exports' file on {gHost_Name[hostRef]}")
                HostComm.executeOnOneHostWithWait(hostRef, \
                    f"echo {gPassword[0]} | sudo -S ./removeALine /etc/exports nfsTest")
                print (f" Restart NFS server on {gHost_Name[hostRef]}")
                HostComm.executeOnOneHostWithWait(hostRef, \
                    f"echo {gPassword[0]} | sudo -S systemctl restart nfs-kernel-server")
                print (f" Delete '/var/nfsTest/*' on {gHost_Name[hostRef]}")
                HostComm.executeOnOneHostWithWait(hostRef, \
                    f"echo {gPassword[0]} | sudo -S rm -rf /var/nfsTest")
                print (f" Delete '/nfsTest/*' on {gHost_Name[hostRef]}")
                HostComm.executeOnOneHostWithWait(hostRef, \
                    f"echo {gPassword[0]} | sudo -S rm -rf /nfsTest")

        print ("")
                    
        cleanIt()

        # See if any directories with stale file handles exist and reboot the host if so
        cleanAgain = False
        print ("")
        for hostRef in range(1, len(gHost_RowStatus)):
            print (f" Check for populated '/nfsTest' (client mount) directories on {gHost_Name[hostRef]}")
            (i, o, e) = HostComm.executeOnOneHostWithWait(hostRef, \
                f"echo {gPassword[0]} | sudo -S ls -al /nfsTest")
            output = o.read().decode()
            print (output)
            retcode = o.channel.recv_exit_status()
            if not retcode:

                print (f" Reboot {gHost_Name[hostRef]}")
                print ("")

                HostComm.executeOnOneHostWithWait(hostRef, \
                    f"echo {gPassword[0]} | sudo -S shutdown -r now")

                HostComm.hostConnections[hostRef] = None
                cleanAgain = True
                
        HostComm.reconnectRebootingHosts()
            
        if cleanAgain:
            cleanIt()
            
        print ("")
        input (" Hit Enter to continue: ")

    # Process user input
    def processCommand(command):
    
        # Help
        if command == "help":
        
            print (InLineText.getText("Help"))
            input (" Enter <CR> to continue: ")
            
            
        elif command == "cleanall":

            UI.cleanAll()


        elif command == "put":
        
            HostComm.putFile(int(input(" hostRef: ")), input("Src: "), input("Dest: "))


        elif command == "get":
        
            HostComm.getFile(int(input(" hostRef: ")), input("Src: "), input("Dest: "))

            
        # Execute command(s) on user-selectable hosts
        elif command == "ecmd":
        
            hostRefList = [None, None]
            
            while len(hostRefList):
        
                hostRefList = HostComm.getHostRefList("Enter where to execute the command(s): ", processControlHost = True)
                
                if len(hostRefList):
                
                    command = "dummy"
                    
                    while command:

                        print ("")
                        print ("systemctl status ssh")
                        print ("")
                        command = input (" Enter the command to execute remotely: ")
                        command = command.strip()

                        if command:
                            for hostRef in hostRefList:
                                (i, o, e) = HostComm.executeOnOneHost(hostRef, command.strip())
                                print ("")
                                print ("retcode = ", o.channel.recv_exit_status())
                                print ("")
                                print (o.read().decode())
                                print ("")
                                print (f"stderr = {e.read().decode()}")
                                print ("")
                                print ("retcode = ", o.channel.recv_exit_status())
                                print ("")
                                print (f"Output from {gHost_Name[hostRef]} / {gHost_Identifier[hostRef]} / {gHost_IP[hostRef]} / {gHost_Hostname[hostRef]}")
                                print ("")


        # Install necessary software packages on selected hosts
        elif command == "insw":
        
            Platform.loadSWOnTestHosts()


        # Process "start a test run" command
        elif command == "st":

            if Configurator.mainTestProcess is not None:
                print ("")
                print (" Can't start a test run more than once")
                print ("")
                time.sleep(2)
            else:

                gActivatorState[0] = "Waiting"

                Configurator.mainTestProcess = Process(target = Configurator.startATestRunProcess, \
                                                         name = "main test process", \
                                                         args = ())
                Configurator.mainTestProcess.start()


        elif command == "swap2":
        
            if gActivatorState[0] != "Activate randomly":
                print ("")
                print (" Must be running a test ('st' command)")
                time.sleep(2)
            else:
                gActivatorState[0] = "Swap host #2's role"


        elif command == "reboot1":
        
            #
            # This handles a reboot. It needs to go in it's own thread so the screen can
            # be updated while this happens.
            #
            
            if gActivatorState[0] != "Activate randomly":
                print ("")
                print (" Must be running a test ('st' command)")
                time.sleep(2)

            else:

                print ("")
                print (" Set host #1 to be rebooted")
                gHost_Reboot[1] = True
                print (" Wait for all its state machine threads to acknowlege")
                Configurator.waitForAllRebooting(hostRef = 1)
                
                # Set to renew any old (invalid) mainline host connection
                HostComm.hostConnections[1] = None
                # Force a new connection
                HostComm.reconnectRebootingHosts()
                print (" Actually do the reboot")
                HostComm.executeOnOneHostWithWait(1, \
                    f"echo {gPassword[0]} | sudo -S shutdown -r now")
                
                print (" Wait for the host to shut down")
                time.sleep(1)

                print (" And now wait for it to start up")
                
                totalWait = 20
                while totalWait:
                    print (f" Waiting for {totalWait} seconds for host to reboot")
                    time.sleep(5)
                    totalWait -= 5
                
                # Zap the connection object again and...
                HostComm.hostConnections[1] = None
                # ...try to reconnect until it works
                HostComm.reconnectRebootingHosts()
                    
                gHost_Reboot[1] = False

        
        elif command == "sa":
        
            gActivatorState[0] = "Activate randomly"


        elif command == "ea":
        
            gActivatorState[0] = "Deactivate randomly"


        # Dump host table
        elif command == "dh":
            gHost_DumpTable()
            print ("")
            input (" Hit Enter to continue: ")

            
        # Dump FS export table
        elif command == "de":
            gExportFS_DumpTable()
            print ("")
            input (" Hit Enter to continue: ")

            
        # Dump FS import table
        elif command == "di":
            gImportFS_DumpTable()
            print ("")
            input (" Hit Enter to continue: ")

            
        # Dump FS user table
        elif command == "du":
            gFSUser_DumpTable()
            print ("")
            input (" Hit Enter to continue: ")

            
        else:
            UI.lastCommand = ""
            print ("")
            print (f"Invalid command: '{command}'")
            time.sleep(2)

        return


    # Service the updating of the terminal screen
    def serviceTerminal(getInput):
    
        gDisplayGenerationTime[0] = time.time()
        
        MasterLock.lock()
        
        displayLines = "\033[H\033[J \n"

        # Decide what display to show
        if UI.displayName == "configuratorStates":
        
            x = Color.RED
            y = Color.WHITE
            displayLines += " Uptime: %d secs; Activator state: %s%s%s \n" % ((time.time() - gStartTime[0]), x, gActivatorState[0], y)
            
            displayLines += " \n"
            displayLines += Configurator.generateStatisticsDisplay(displayLines)
            
            MasterLock.unlock()
            
            # Update menu
            displayLines += " \n"
            displayLines += " dh / de / di / du = Dump hosts / exportFS / importFS / FSUser tables \n"
            
            displayLines += " insw          = Install all necessary software packages on any host(s) \n"
            displayLines += " cleanall      = Clean up all artifacts on all test host(s) no matter what \n"
            displayLines += " ecmd          = Execute command(s) on any host(s) \n"
            displayLines += " st / sa / ea  = Start testing / start activation / end activation \n"
            displayLines += " swap2 / reboot1  = swap role of host #2 / reboot host #1 \n"
            displayLines += " \n"
                
            displayLines += " help     = Print help on the screen \n"
            displayLines += " \n"
            displayLines += f" Last command = '{UI.lastCommand}' \n"
    
            # Print whole screen with one "print" (no flashing)
            print (displayLines)

            if (time.time() - gStartTime[0]) > 1200:
                print ("")
                print ("Stopping after 20 minutes so we don't consume a lot disk space in nfsTest.log.")
                print ("")
                gAllStop[0] = True
                time.sleep(100000)            

            # Clean the test hosts the first time through this code
            if UI.firstTime:
                print ("")
                answer = input(" Enter 'y' to 'clean all' test hosts: ")
                if answer == "y":
                    UI.cleanAll()
                print ("")

            i = ""
            if (not UI.firstTime) and (getInput):
                # Get any user input and also pause for 2 seconds
                print (" Type a command from the menu above then hit Enter:")
                i, o, e = select.select([sys.stdin], [], [], 2)
            else:
                time.sleep(2)

                # No longer the first time
            UI.firstTime = False
            
            # If some input
            if i:
                
                command = sys.stdin.readline().strip()
                
                UI.lastCommand = command

                # Process user input
                UI.processCommand(command)

        return ()
        

    # Watch/control what's going on from the display rendered on the terminal
    def coreInteractiveLogic():
    
        # Always update the screen
        while not gAllStop[0]:

            # Update screen and process any user input
            UI.serviceTerminal(getInput = True)
            
        time.sleep(100000)


"""

Program flow:

Command "st" starts one "mainTestProcesses" in "startATestRunProcess"
    Define state machine rows in defineAllResourceControlRows in "startATestRunProcess"
    Start one "perHostResourceManagementProcesses" per host in "startATestRunProcess"
        Start one "resourceThreads" per resource row in "startAllConfiguratorThreads"
    Advance the state machine(s) in "activator"
    
Host communication operation:

Paramiko is not thread safe so we need a separate Paramiko object per host, per thread.

ssh has a limit of 10 connection attempts per second. We handle this by only connecting 
to a host when we need to.

So, to reboot a server(s) host:

    Configurator process:
        Set gHost_Reboot[hostRef] = True
        (Note, we only reboot servers)
        
    Resource threads:
        Complete their work
        if the current gHost is rebooting
            Save their current resource state
            Set each of their host connection objects to None
            Set their resource state to Rebooting
        
    Configurator process:
        When all resources for rebooting hosts are in Rebooting state
        Reboot the host
        Clear gHost reboot flag
        
    Resource threads:
        Upon noticing clearing of gHost reboot flag
        Move back to saved state
        Host commands loop on connecting to host

"""

class Configurator:

    # Must be mindful of the process / thread contexts these are being used in
    mainTestProcess = None                      # Spawned from THE main thread (in startATestRunProcess)
    perHostResourceManagementProcesses = []     # Spawned from the above process (in startAConfiguratorProcessesPerHost)
    resourceThreads = []                        # Spawned from the above processes (in startAllConfiguratorThreads)
    hostConnections = []                        # Per host, per thread Paramiko connection
    
    # These are per-host, per-thread connection objects 
    hostConnection = None
    exportFSConnections = []
    importFSConnections = []
    fsUserConnections = []

    # These are set by entries in the nfsTest.conf file. They control the size and shape
    # of the configuration being tested and the rate at which it operates
    exportFSPerHost = None
    fsUserPerImportFS = None

    # The below control how the activator works and also come from the nfsTest.conf file
    secondsPerStateTransition = None
    transitionsPerHost = None
    transitionsPerExportFS = None
    transitionsPerImportFS = None
    transitionsPerFSUser = None
    
    # Wait for all applicable state machines to be in "Rebooting" state
    def waitForAllRebooting(hostRef):
    
        notRebootingCount = 1
        while notRebootingCount > 0:
        
            notRebootingCount = 0
        
            if gHost_State[hostRef] != "Rebooting":
                notRebootingCount += 1
                
            for exportFSRef in range(len(gExportFS_RowStatus)):
                if (gExportFS_gHost_Ref[exportFSRef] == hostRef) and \
                   (gExportFS_State[exportFSRef] != "Rebooting"):
                    notRebootingCount += 1
                    
            if notRebootingCount > 0:
                time.sleep(2)

    # Do this during a reboot
    def resetAllHostConnections():
    
        for hostConnRef in range(len(Configurator.hostConnections)):
            Configurator.hostConnections[hostConnRef] = None
    
    #
    # Keep trying to connect to the host if necessary and then communicate with it
    #
    def talkToHost(hostConnRef, hostRef, command):

        # If there's no active host connection keep trying to get one
        while Configurator.hostConnections[hostConnRef] is None:

            logging.info(f"Trying to connect to {gHost_Name[hostRef]} using {hostConnRef}; {command}")
    
            try:

                tempConnection = paramiko.client.SSHClient()
                tempConnection.set_missing_host_key_policy(paramiko.AutoAddPolicy())
                tempConnection.connect(gHost_IP[hostRef], username = gUsername[0], password = gPassword[0])
                
                Configurator.hostConnections[hostConnRef] = tempConnection

            except Exception as e:
            
                MasterLock.unlock()
            
                time.sleep(5)
                
                MasterLock.lock()
            
        # We're in - talk...
        (i, o, e) = Configurator.hostConnections[hostConnRef].exec_command(command)

        retcode = o.channel.recv_exit_status()
        
        if retcode:
        
            logging.info(f"Execute on {gHost_Name[hostRef]}; {command} failed !!!!!!!!!!!!!!!!!!!!")
            logging.info(f"Execute on {gHost_Name[hostRef]}; {command} failed !!!!!!!!!!!!!!!!!!!!")
            logging.info(f"Execute on {gHost_Name[hostRef]}; {command} failed !!!!!!!!!!!!!!!!!!!!")

            logging.info("")
            logging.info(f"retcode = {retcode}")
            logging.info("")
            logging.info(f"Host = #{hostRef}")
            logging.info("")
            logging.info(f"Command = {command}")
            logging.info("")
            logging.info(o.read().decode())
            logging.info("")
            logging.info(f"stderr = {e.read().decode()}")
            logging.info("")
            logging.info(f"retcode = {retcode}")
            logging.info("")
            logging.info(f"Output above from {gHost_Name[hostRef]}")
            logging.info("")

            gActivatorState[0] = "Waiting for a command error to be investigated - see nfsTest.log"
            
            time.sleep(100000)
            
        return (o.read().decode())

    def calculateStatistics():
    
        gHostInactive[0] = gHost_State.count("Inactive")
        gHostActivating[0] = gHost_State.count("Activating")
        gHostActive[0] = gHost_State.count("Active")
        gHostDeactivating[0] = gHost_State.count("Deactivating")
        gHostRebooting[0] = gHost_State.count("Rebooting")
    
        gExportFSInactive[0] = gExportFS_State.count("Inactive")
        gExportFSActivating[0] = gExportFS_State.count("Activating")
        gExportFSActive[0] = gExportFS_State.count("Active")
        gExportFSDeactivating[0] = gExportFS_State.count("Deactivating")
        gExportFSRebooting[0] = gExportFS_State.count("Rebooting")
    
        gImportFSInactive[0] = gImportFS_State.count("Inactive")
        gImportFSActivating[0] = gImportFS_State.count("Activating")
        gImportFSActive[0] = gImportFS_State.count("Active")
        gImportFSDeactivating[0] = gImportFS_State.count("Deactivating")
    
        gFSUserInactive[0] = gFSUser_State.count("Inactive")
        gFSUserActivating[0] = gFSUser_State.count("Activating")
        gFSUserActive[0] = gFSUser_State.count("Active")
        gFSUserDeactivating[0] = gFSUser_State.count("Deactivating")
        
        gAllInactive[0] = gHostInactive[0] + gExportFSInactive[0] + gImportFSInactive[0] + gFSUserInactive[0]
        gAllActivating[0] = gHostActivating[0] + gExportFSActivating[0] + gImportFSActivating[0] + gFSUserActivating[0]
        gAllActive[0] = gHostActive[0] + gExportFSActive[0] + gImportFSActive[0] + gFSUserActive[0]
        gAllDeactivating[0] = gHostDeactivating[0] + gExportFSDeactivating[0] + gImportFSDeactivating[0] + gFSUserDeactivating[0]
        gAllRebooting[0] = gHostRebooting[0] + gExportFSRebooting[0]        
        
        return
            
    def generateStatisticsDisplay(displayLines):

        Configurator.calculateStatistics()
    
        displayLines += "                    Host     exportFS     importFS       FSUser \n"
        displayLines += " Resource state    Count        Count        Count        Count \n"
        displayLines += " --------------    -----     --------     --------       ------ \n"
        displayLines += " Inactive           %4d         %4d         %4d         %4d \n" % (gHostInactive[0], gExportFSInactive[0], gImportFSInactive[0], gFSUserInactive[0])
        displayLines += " Activating         %4d         %4d         %4d         %4d \n" % (gHostActivating[0], gExportFSActivating[0], gImportFSActivating[0], gFSUserActivating[0])
        displayLines += " Active             %4d         %4d         %4d         %4d \n" % (gHostActive[0], gExportFSActive[0], gImportFSActive[0], gFSUserActive[0])
        displayLines += " Deactivating       %4d         %4d         %4d         %4d \n" % (gHostDeactivating[0], gExportFSDeactivating[0], gImportFSDeactivating[0], gFSUserDeactivating[0])
        displayLines += " Rebooting          %4d         %4d         %4d         %4d \n" % (gHostRebooting[0], gExportFSRebooting[0], 0, 0)
        #displayLines += " Disabling          %4d         %4d         %4d         %4d \n" % (gHostDisabling[0], gExportFSDisabling[0], gImportFSDisabling[0], gFSUserDisabling[0])
        #displayLines += " Disabled           %4d         %4d         %4d         %4d \n" % (gHostDisabled[0], gExportFSDisabled[0], gImportFSDisabled[0], gFSUserDisabled[0])
        displayLines += " \n"
        
        displayLines += "                  Host          Host     ExportFS   ImportFS   FSUser  Finished  \n"
        displayLines += " Host ID          Role          State    Use Cnt    Use Cnt    Use Cnt I/O Count \n"
        displayLines += " -------          ----          -----    --------   --------   ------- --------- \n"
        
        for hostRef in range(len(gHost_RowStatus)):
            if hostRef == 0:

                displayLines += "%8s      %8s \n" % (gHost_Name[hostRef], gHost_Role[hostRef])
            
            else:
            
                displayLines += "%8s      %8s   %12s        %4d       %4d     %4d       %4d \n" % (gHost_Name[hostRef], \
                                                                                             gHost_Role[hostRef], \
                                                                                             gHost_State[hostRef], \
                                                                                             gHost_ExportFSUseCount[hostRef], \
                                                                                             gHost_ImportFSUseCount[hostRef], \
                                                                                             gHost_FSUserUseCount[hostRef], \
                                                                                             gHost_IOCount[hostRef])
        displayLines += " \n"
        displayLines += f" Display generation time = {int((time.time() - gDisplayGenerationTime[0]) * 1000)} ms \n"
        
        return (displayLines)
    
    def startATestRunProcess():
    
        # Define all gDS rows per resource
        Configurator.defineAllResourceControlRows()
        # Start a process per host row and they then each start a thread per resource row for that host
        Configurator.startAConfiguratorProcessesPerHost()
        # Start to activate resources
        Configurator.activator()
        # <End of thread>

    def defineAllResourceControlRows():
    
        # gHost rows already exist...
    
        # Make all possible, legal export FS rows
        for hostRef in range(1, len(gHost_RowStatus)):
            for exportFSNum in range(Configurator.exportFSPerHost):
                exportFSRef = gExportFS_AddARow(_gHost_Ref = hostRef,
                                                _Name = f"host_{'%4.4x' %(hostRef)}_export_{'%4.4x' % (len(gExportFS_RowStatus))}")
                logging.info(f"Add export FS row for {gHost_Name[hostRef]}")
                                            
        # Make all possible, legal import FS rows for the export FS rows
        for hostRef in range(1, len(gHost_RowStatus)):
            for exportFSRef in range(len(gExportFS_RowStatus)):
                # Do not make imports that match exports
                if not hostRef == gExportFS_gHost_Ref[exportFSRef]:
                    importFSRef = gImportFS_AddARow(_gHost_Ref = hostRef,
                                                    _gExportFS_Ref = exportFSRef,
                                                    _Name = f"host_{'%4.4x' % (hostRef)}_export_{'%4.4x' % (exportFSRef)}_import_{'%4.4x' % (len(gImportFS_RowStatus))}")
                    logging.info(f"Add import FS row for {gHost_Name[hostRef]}, {gExportFS_Name[exportFSRef]}")
                
        # Make all possible, legal FS User rows to go up against the import FS rows
        for hostRef in range(1, len(gHost_RowStatus)):
            for importFSRef in range(len(gImportFS_RowStatus)):
                # Only make rows for FS users on the same host as the import
                if hostRef == gImportFS_gHost_Ref[importFSRef]:
                    for fsUserNum in range(Configurator.fsUserPerImportFS):
                        fsUserRef = gFSUser_AddARow(_gHost_Ref = hostRef,
                                                    _gExportFS_Ref = gImportFS_gExportFS_Ref[importFSRef],
                                                    _gImportFS_Ref = importFSRef,
                                                    _Name = f"host_{'%4.4x' % (gImportFS_gHost_Ref[importFSRef])}_export_{'%4.4x' % (gImportFS_gExportFS_Ref[importFSRef])}_import_{'%4.4x' % (importFSRef)}_user_{'%4.4x' % (len(gFSUser_RowStatus))}")
                        logging.info(f"Add FS user row for {gHost_Name[hostRef]}, {gImportFS_Name[importFSRef]}")

        return
    
    # Start one process per host; that process starts the 4 types of state management threads
    def startAConfiguratorProcessesPerHost():
    
        MasterLock.lock()
        for hostRef in range(1, len(gHost_RowStatus)):
            Configurator.perHostResourceManagementProcesses.append(Process(target = Configurator.startAllConfiguratorThreads, \
                                                                      name = gHost_Name[hostRef] + " control process" , \
                                                                      args = [hostRef,]))
            Configurator.perHostResourceManagementProcesses[-1].start()
        MasterLock.unlock()
        
    def startAllConfiguratorThreads(hostRef):
    
        #
        # We are a process on each host so make all the necessary control threada (per host)
        #
        MasterLock.lock()
        
        # Start a manage host thread
        Configurator.resourceThreads.append(Thread(target = Configurator.manageHost, \
                                             name = gHost_Name[hostRef], \
                                             args = [hostRef, len(Configurator.hostConnections)]))
        Configurator.hostConnections.append(None)
        Configurator.resourceThreads[-1].start()

        # Iterate over export FS rows that cite this thread's host
        for exportFSRef in range(len(gExportFS_RowStatus)):
            if gExportFS_gHost_Ref[exportFSRef] == hostRef:
                Configurator.resourceThreads.append(Thread(target = Configurator.manageExportFS, \
                                                     name = gExportFS_Name[exportFSRef], \
                                                     args = [exportFSRef, len(Configurator.hostConnections)]))
                Configurator.hostConnections.append(None)
                Configurator.resourceThreads[-1].start()

        # Iterate over import FS rows that cite this thread's host
        for importFSRef in range(len(gImportFS_RowStatus)):
            if gImportFS_gHost_Ref[importFSRef] == hostRef:
                Configurator.resourceThreads.append(Thread(target = Configurator.manageImportFS, \
                                                     name = gImportFS_Name[importFSRef], \
                                                     args = [importFSRef, len(Configurator.hostConnections)]))
                Configurator.hostConnections.append(None)
                Configurator.resourceThreads[-1].start()

        # Iterate over FS user rows that cite this thread's host
        for fsUserRef in range(len(gFSUser_RowStatus)):
            if gFSUser_gHost_Ref[fsUserRef] == hostRef:
                Configurator.resourceThreads.append(Thread(target = Configurator.manageFSUser, \
                                                     name = gFSUser_Name[fsUserRef], \
                                                     args = [fsUserRef, len(Configurator.hostConnections)]))
                Configurator.hostConnections.append(None)
                Configurator.resourceThreads[-1].start()

        MasterLock.unlock()
        
        time.sleep(1)
        
    def activator():

        #
        # A way to slowly, randomly transition the state machine states
        #
        def randomTransitionChain(currentState, nextState):
        
            for i in range(Configurator.transitionsPerHost):
                hostRef = random.randrange(1, len(gHost_RowStatus))
                if gHost_State[hostRef] == currentState:
                    gHost_State[hostRef] = nextState

            for i in range(Configurator.transitionsPerExportFS):
                exportFSRef = random.randrange(len(gExportFS_RowStatus))
                if gExportFS_State[exportFSRef] == currentState:
                    gExportFS_State[exportFSRef] = nextState

            for i in range(Configurator.transitionsPerImportFS):
                importFSRef = random.randrange(len(gImportFS_RowStatus))
                if gImportFS_State[importFSRef] == currentState:
                    gImportFS_State[importFSRef] = nextState

            for i in range(Configurator.transitionsPerFSUser):
                fsUserRef = random.randrange(len(gFSUser_RowStatus))
                if gFSUser_State[fsUserRef] == currentState:
                    gFSUser_State[fsUserRef] = nextState
            
            return

        while True:
        
            MasterLock.lock()
        
            if gActivatorState[0] == "Activate randomly":
            
                randomTransitionChain("Inactive", "Activating")

            elif (gActivatorState[0] == "Deactivate randomly"):

                randomTransitionChain("Active", "Deactivating")
                
            elif gActivatorState[0] == "Swap host #2's role":
            
                #
                # The swap code is here for now because we can't have the activator
                # operating on the host we are swapping roles on. 
                #
                if gHost_State[2] == "Active":
                
                    # Set host #2 deactivating and
                    gHost_State[2] = "Deactivating"
                
                    # Wait for all its "users" and it to stop
                    while gHost_State[2] != "Inactive":
                        MasterLock.unlock()
                        time.sleep(1)
                        MasterLock.lock()
                        
                    # Leave above in locked state!
                        
                    # Sleeps are for looks in the UI
                    time.sleep(1)
                    
                    # Force stalled "Activating" resources back to "Inactive"
                    for hostRef in range(len(gHost_RowStatus)):
                        if gHost_State[hostRef] == "Activating":
                            gHost_State[hostRef] = "Inactive"

                    for exportFSRef in range(len(gExportFS_RowStatus)):
                        if gExportFS_State[exportFSRef] == "Activating":
                            gExportFS_State[exportFSRef] = "Inactive"

                    for importFSRef in range(len(gImportFS_RowStatus)):
                        if gImportFS_State[importFSRef] == "Activating":
                            gImportFS_State[importFSRef] = "Inactive"

                    for fsUserRef in range(len(gFSUser_RowStatus)):
                        if gFSUser_State[fsUserRef] == "Activating":
                            gFSUser_State[fsUserRef] = "Inactive"

                    time.sleep(1)

                    if gHost_Role[2] == "Client":
                        gHost_Role[2] = "Server"
                    else:
                        gHost_Role[2] = "Client"
                        
                    time.sleep(1)
                        
                    gActivatorState[0] = "Activate randomly"
                
            elif gActivatorState[0].startswith("Waiting"):

                MasterLock.unlock()
                time.sleep(1)
                MasterLock.lock()
                
            else:
            
                print (gActivatorState[0])
                x = 1/0     # Invalid activator state                 
                
            MasterLock.unlock()
            
            time.sleep(3)
                
        return

    #
    # The operations below move the host, export and importfile systems, and the user state machines
    # through the given usage patterns.
    #
    
    # Arrangement of use counts:
    #
    # gHost         (per host)          ExportFSUseCount    ImportFSUseCount    FSUserUseCount
    # gExportFS     (per export)        ImportFSUseCount
    # gImportFS     (per import)        FSUserUseCount
    # gFSUser
    
    # The code runs the host through its states but does little otherwise
    def manageHost(hostRef, hostConnRef):
    
        while not gAllStop[0]:
        
            MasterLock.lock()
        
            # If activating a server
            if gHost_Role[hostRef] == "Server":

                # Handle a reboot for this server host
                if gHost_Reboot[hostRef]:
                
                    gHost_PrevState[hostRef] = gHost_State[hostRef]
                    gHost_State[hostRef] = "Rebooting"
                    Configurator.resetAllHostConnections()
                    while gHost_Reboot[hostRef]:
                        MasterLock.unlock()
                        time.sleep(5)
                        MasterLock.lock()
                    gHost_State[hostRef] = gHost_PrevState[hostRef]
            
                elif gHost_State[hostRef] == "Activating":
            
                    logging.info(f"Activate name = {gHost_Name[hostRef]}; role = {gHost_Role[hostRef]}; state = {gHost_State[hostRef]}")

                    gHost_State[hostRef] = "Active"
                    
                # If an active server, do nothing
                elif gHost_State[hostRef] == "Active":
                
                    pass

                # If deactivating a server, first wait for its use counts to go to zero
                elif (gHost_State[hostRef] == "Deactivating") and \
                     (gHost_ExportFSUseCount[hostRef] == 0):

                    logging.info(f"Deactivate name = {gHost_Name[hostRef]}; role = {gHost_Role[hostRef]}; state = {gHost_State[hostRef]}")

                    gHost_State[hostRef] = "Inactive"

                # If unused server, do nothing
                elif (gHost_State[hostRef] == "Inactive"):
                
                    pass

                # If disabling the server just do it
                elif gHost_State[hostRef] == "Disabling":
                
                    gHost_State[hostRef] = "Disabled"
                    
            # If activating a client
            elif gHost_Role[hostRef] == "Client":
            
                if gHost_State[hostRef] == "Activating":
            
                    logging.info(f"Activate name = {gHost_Name[hostRef]}; role = {gHost_Role[hostRef]}; state = {gHost_State[hostRef]}")

                    gHost_State[hostRef] = "Active"
                    
                # If an active client, do nothing
                elif gHost_State[hostRef] == "Active":
                
                    pass

                # If deactivating a client, first wait for its use counts to go to zero
                elif (gHost_State[hostRef] == "Deactivating") and \
                     (gHost_ImportFSUseCount[hostRef] == 0) and \
                     (gHost_FSUserUseCount[hostRef] == 0):
                    
                    logging.info(f"Deactivate name = {gHost_Name[hostRef]}; role = {gHost_Role[hostRef]}; state = {gHost_State[hostRef]}")
                    
                    gHost_State[hostRef] = "Inactive"

                # If unused client, do nothing
                elif gHost_State[hostRef] == "Inactive":
                
                    pass

                # If disabling the client, do it and exit thread
                elif gHost_State[hostRef] == "Disabling":
                
                    gHost_State[hostRef] = "Disabled"
                    
            # Unlock to wait in loop
            MasterLock.unlock()
        
            time.sleep(Configurator.secondsPerStateTransition)
            
        time.sleep(100000)

    # Create and export a FS on the host
    def manageExportFS(exportFSRef, hostConnRef):
    
        serverHostRef = gExportFS_gHost_Ref[exportFSRef]

        def createExportFS():
        
            Configurator.talkToHost(hostConnRef, serverHostRef, \
                f"echo {gPassword[0]} | sudo -S mkdir -p /var/nfsTest/{gExportFS_Name[exportFSRef]}")
            Configurator.talkToHost(hostConnRef, serverHostRef, \
                f"echo {gPassword[0]} | sudo -S chown -R nobody:nogroup /var/nfsTest")
                
            Configurator.talkToHost(hostConnRef, serverHostRef, \
                f"echo {gPassword[0]} | sudo -S ./appendALine /etc/exports '/var/nfsTest/{gExportFS_Name[exportFSRef]} *(rw,sync,no_subtree_check)'")

            Configurator.talkToHost(hostConnRef, serverHostRef, \
                f"echo {gPassword[0]} | sudo -S systemctl restart nfs-kernel-server")
                
            return

        def destroyExportFS():
        
            Configurator.talkToHost(hostConnRef, serverHostRef, \
                f"echo {gPassword[0]} | sudo -S ./removeALine /etc/exports '/var/nfsTest/{gExportFS_Name[exportFSRef]} *(rw,sync,no_subtree_check)'")

            Configurator.talkToHost(hostConnRef, serverHostRef, \
                f"echo {gPassword[0]} | sudo -S systemctl restart nfs-kernel-server")
                
            Configurator.talkToHost(hostConnRef, serverHostRef, \
                f"echo {gPassword[0]} | sudo -S rm -rf /var/nfsTest/{gExportFS_Name[exportFSRef]}")
                
            return

        # ExportFS actions
        while not gAllStop[0]:

            MasterLock.lock()

            # If this exported FS belongs to a host that's a server type at this time
            if gHost_Role[serverHostRef] == "Server":
            
                # Handle a reboot for this server host
                if gHost_Reboot[serverHostRef]:
                
                    gExportFS_PrevState[exportFSRef] = gExportFS_State[exportFSRef]
                    gExportFS_State[exportFSRef] = "Rebooting"
                    Configurator.resetAllHostConnections()
                    while gHost_Reboot[serverHostRef]:
                        MasterLock.unlock()
                        time.sleep(5)
                        MasterLock.lock()
                    gExportFS_State[exportFSRef] = gExportFS_PrevState[exportFSRef]
            
                # Directed deactivation of a server host!!
                # If host is being deactivated and the export FS is unused deactivate it
                elif (gHost_State[serverHostRef] == "Deactivating") and \
                   (gExportFS_State[exportFSRef] == "Active") and \
                   (gExportFS_ImportFSUseCount[exportFSRef] == 0):
                   
                    if gSMNFSFunctionsEnabled[0]:
                        destroyExportFS()

                    # Track exported FS and backing host
                    gHost_ExportFSUseCount[serverHostRef] -= 1
                    gExportFS_State[exportFSRef] = "Inactive"
                
                # If activating an exported FS and the server is active
                elif (gExportFS_State[exportFSRef] == "Activating") and \
                   (gHost_State[serverHostRef] == "Active"):
               
                    # Make and export the FS
                    logging.info(f"Activate Export FS #{exportFSRef}; host = {gHost_Name[serverHostRef]}; name = {gExportFS_Name[exportFSRef]}; state = {gExportFS_State[exportFSRef]}")
                    
                    if gSMNFSFunctionsEnabled[0]:
                        createExportFS()

                    # Track exported FS
                    gHost_ExportFSUseCount[serverHostRef] += 1
                    gExportFS_State[exportFSRef] = "Active"
                
                # If managing an active exported FS; do nothing
                elif gExportFS_State[exportFSRef] == "Active":
               
                    # Do nothing
                    pass
                
                # If deactivating an exported FS and its use count is zero
                elif (gExportFS_State[exportFSRef] == "Deactivating") and \
                     (gExportFS_ImportFSUseCount[exportFSRef] == 0):
               
                    # Destroy the exported FS
                    logging.info(f"Deactivate Export FS #{exportFSRef}; name = {gExportFS_Name[exportFSRef]}; state = {gExportFS_State[exportFSRef]}")
                    
                    if gSMNFSFunctionsEnabled[0]:
                        destroyExportFS()

                    # Track exported FS and backing host
                    gHost_ExportFSUseCount[serverHostRef] -= 1
                    gExportFS_State[exportFSRef] = "Inactive"
                
                # If managing an unused exported FS; do nothing
                elif gExportFS_State[exportFSRef] == "Inactive":
               
                    # Do nothing
                    pass

                # If disabling the export FS, do it and exit thread
                elif gExportFS_State[exportFSRef] == "Disabling":
                
                    gExportFS_State[exportFSRef] = "Disabled"
                    
                    # Exit the control thread
                    MasterLock.unlock()

            MasterLock.unlock()
    
            time.sleep(Configurator.secondsPerStateTransition)
            
        time.sleep(100000)
        
    def manageImportFS(importFSRef, hostConnRef):

        # Get refs of who we are using
        clientHostRef = gImportFS_gHost_Ref[importFSRef]
        exportFSRef = gImportFS_gExportFS_Ref[importFSRef]
        serverHostRef = gExportFS_gHost_Ref[exportFSRef]
    
        def createImportFS():
        
            Configurator.talkToHost(hostConnRef, clientHostRef, \
                f"echo {gPassword[0]} | sudo -S mkdir -p /nfsTest/{gImportFS_Name[importFSRef]}")
                
            # Mount the !exported FS! as the !imported FS!
            Configurator.talkToHost(hostConnRef, clientHostRef, \
                f"echo {gPassword[0]} | sudo -S mount -o actimeo=5 {gHost_IP[gExportFS_gHost_Ref[exportFSRef]]}:/var/nfsTest/{gExportFS_Name[exportFSRef]} /nfsTest/{gImportFS_Name[importFSRef]}")

            Configurator.talkToHost(hostConnRef, clientHostRef, \
                f"echo {gPassword[0]} | sudo -S ./appendALine /etc/fstab '{gHost_IP[gExportFS_gHost_Ref[exportFSRef]]}:/var/nfsTest/{gExportFS_Name[exportFSRef]}  {gImportFS_Name[importFSRef]}  nfs auto,nofail,noatime,nolock,intr,tcp,actimeo=5 0 0'")

            Configurator.talkToHost(hostConnRef, clientHostRef, \
                f"echo {gPassword[0]} | sudo -S mkdir -p /var/ioEngine")
                
            return
    
        def destroyImportFS():
        
            # Un-mount the !imported! FS
            Configurator.talkToHost(hostConnRef, clientHostRef, \
                f"echo {gPassword[0]} | sudo -S umount /nfsTest/{gImportFS_Name[importFSRef]}")

            Configurator.talkToHost(hostConnRef, clientHostRef, \
                f"echo {gPassword[0]} | sudo -S ./removeALine /etc/fstab '{gHost_IP[gExportFS_gHost_Ref[exportFSRef]]}:/var/nfsTest/{gExportFS_Name[exportFSRef]}  {gImportFS_Name[importFSRef]}'")

            Configurator.talkToHost(hostConnRef, clientHostRef, \
                f"echo {gPassword[0]} | sudo -S rm -rf /nfsTest/{gImportFS_Name[importFSRef]}")
                
            return
    
        # ImportFS actions
        while not gAllStop[0]:
        
            MasterLock.lock()
            
            # If this import FS belongs to a host that's a client type at this time
            if gHost_Role[clientHostRef] == "Client":

                # "Directed deactivation" (deactivate started by someone "Deactivating" host(s)) of a client or server host!!
                # (and..) If deactivating the client or server host and the import FS is active and unused, stop the import FS
                if ((gHost_State[clientHostRef] == "Deactivating") or \
                    (gHost_State[serverHostRef] == "Deactivating")) and \
                   (gImportFS_State[importFSRef] == "Active") and \
                   (gImportFS_FSUserUseCount[importFSRef] == 0):
                   
                    # Unmount an imported FS
                    logging.info(f"Directed deactivate Import FS #{importFSRef}; name = {gImportFS_Name[importFSRef]}; state = {gImportFS_State[importFSRef]}")
                    
                    if gSMNFSFunctionsEnabled[0]:
                        destroyImportFS()
                    
                    # Track activity of host, export and import FS
                    gExportFS_ImportFSUseCount[exportFSRef] -= 1
                    gHost_ImportFSUseCount[clientHostRef] -= 1
                    gImportFS_State[importFSRef] = "Inactive"
                
                # If activating an import FS and the export is active
                elif (gImportFS_State[importFSRef] == "Activating") and \
                     (gExportFS_State[exportFSRef] == "Active"):
               
                    # Mount an export FS
                    logging.info(f"Activate Import FS #{importFSRef}; name = {gImportFS_Name[importFSRef]}; state = {gImportFS_State[importFSRef]}")
                    
                    if gSMNFSFunctionsEnabled[0]:
                        createImportFS()

                    # Track activity of host and exported FS
                    gExportFS_ImportFSUseCount[exportFSRef] += 1
                    gHost_ImportFSUseCount[clientHostRef] += 1
                    gImportFS_State[importFSRef] = "Active"
                
                # If managing an active imported FS; do nothing
                elif gImportFS_State[importFSRef] == "Active":
               
                    # Do nothing
                    pass
                
                # If deactivating an unused import FS
                elif (gImportFS_State[importFSRef] == "Deactivating") and \
                     (gImportFS_FSUserUseCount[importFSRef] == 0):
               
                    # Unmount an imported FS
                    logging.info(f"Undirected deactivate Import FS #{importFSRef}; name = {gImportFS_Name[importFSRef]}; state = {gImportFS_State[importFSRef]}")
                    
                    if gSMNFSFunctionsEnabled[0]:
                        destroyImportFS()
                    
                    # Track activity of host and exported FS
                    gExportFS_ImportFSUseCount[exportFSRef] -= 1
                    gHost_ImportFSUseCount[clientHostRef] -= 1
                    gImportFS_State[importFSRef] = "Inactive"
                
                # If managing an unused imported FS; do nothing
                elif gImportFS_State[importFSRef] == "Inactive":
               
                    # Do nothing
                    pass
                
                # If disabling the import FS, do it and exit thread
                elif gImportFS_State[importFSRef] == "Disabling":
                
                    gImportFS_State[importFSRef] = "Disabled"
                    
                    # Exit the control thread
                    MasterLock.unlock()

            MasterLock.unlock()
    
            time.sleep(Configurator.secondsPerStateTransition)
            
        time.sleep(100000)

    def manageFSUser(fsUserRef, hostConnRef):
    
        # Get refs of who we are using from the import FS (we are running on the importing host)
        importFSRef = gFSUser_gImportFS_Ref[fsUserRef]
        exportFSRef = gImportFS_gExportFS_Ref[importFSRef]
        clientHostRef = gImportFS_gHost_Ref[importFSRef]    # The host we are running on
        serverHostRef = gExportFS_gHost_Ref[exportFSRef]    # The host our exported FS is running on
        
        # FSUser actions
        while not gAllStop[0]:
        
            MasterLock.lock()

            # If this FS user belongs to a host that's a client type at this time
            if gHost_Role[clientHostRef] == "Client":

                # Directed deactivation of a client or server host!!
                # If deactivating the client host or server host and the FS user is active, stop the FS user
                if ((gHost_State[clientHostRef] == "Deactivating") or \
                    (gHost_State[serverHostRef] == "Deactivating")) and \
                   (gFSUser_State[fsUserRef] == "Active"):
                   
                    # Start no more file system user threads
                    logging.info(f"Deactivate FS user #{fsUserRef}; name = {gFSUser_Name[fsUserRef]}; state = {gFSUser_State[fsUserRef]}")
                    
                    # Track activity
                    gHost_FSUserUseCount[clientHostRef] -= 1
                    gImportFS_FSUserUseCount[importFSRef] -= 1
                    gFSUser_State[fsUserRef] = "Inactive"

                # If creating an FS user and the import is active
                elif (gFSUser_State[fsUserRef] == "Activating") and \
                   (gImportFS_State[importFSRef] == "Active"):

                    # Start a file system user thread
                    logging.info(f"Activate FS user #{fsUserRef}; name = {gFSUser_Name[fsUserRef]}; state = {gFSUser_State[fsUserRef]}")
                    
                    # Track activity
                    gHost_FSUserUseCount[clientHostRef] += 1
                    gImportFS_FSUserUseCount[importFSRef] += 1
                    gFSUser_State[fsUserRef] = "Active"
                
                # If managing an active FS user start I/O and wait for it to finish
                elif gFSUser_State[fsUserRef] == "Active":
               
                    # Get directory name so we can pull parts of ioEngine file name out
                    destPath = f"/nfsTest/{gImportFS_Name[importFSRef]}/"
                    
                    fileNum = gIOEngineNumber[0]
                    gIOEngineNumber[0] += 1
                    
                    # Do / keep doing I/O with no lock
                    MasterLock.unlock()
                    
                    logging.info(f"Use FS user #{fsUserRef}; name = {gFSUser_Name[fsUserRef]}; state = {gFSUser_State[fsUserRef]}")
                    
                    Configurator.talkToHost(hostConnRef, clientHostRef, f"echo {gPassword[0]} | sudo -S ./ioEngine --rt=15 {destPath}/0x{fileNum}")
                    
                    MasterLock.lock()
                    
                    gHost_IOCount[clientHostRef] += 1
                
                # If destroying an FS user
                elif (gFSUser_State[fsUserRef] == "Deactivating"):
               
                    # Do nothing else here; import FS will unmount when use count goes to zero
                    logging.info(f"Deactivate FS user #{fsUserRef}; name = {gFSUser_Name[fsUserRef]}; state = {gFSUser_State[fsUserRef]}")
                    
                    # Track activity
                    gHost_FSUserUseCount[clientHostRef] -= 1
                    gImportFS_FSUserUseCount[importFSRef] -= 1
                    gFSUser_State[fsUserRef] = "Inactive"

                # If managing an unused FS user; do nothing
                elif gFSUser_State[fsUserRef] == "Inactive":
               
                    # Do nothing
                    pass
                
                # If disabling the FS user, do it and exit thread
                elif gFSUser_State[fsUserRef] == "Disabling":
                
                    gFSUser_State[fsUserRef] = "Disabled"
                    
                    # Exit the control thread
                    MasterLock.unlock()

            MasterLock.unlock()
    
            time.sleep(Configurator.secondsPerStateTransition)
            
        time.sleep(100000)


#
# Routines to handle in-line documentation/text (text in this source file that
#     can be extracted at run time and used for help or templates)
#
if __name__ == "__main__":

    logging.basicConfig(filename = 'nfsTest.log', filemode = "a", \
                        format = '%(asctime)s %(processName)s %(threadName)s %(funcName)s %(lineno)d %(message)s', \
                        encoding = 'utf-8', level = logging.INFO)

    logging.info("")
    logging.info("")
    logging.info("Start nfsTest")

    # Load in this program's code for in-line text processing
    InLineText.getCodeLines()
    
    # Enable NFS operations in the state machines (it can be disabled here for debug)
    gSMNFSFunctionsEnabled[0] = True

    # Set the start time
    gStartTime[0] = time.time()
    
    # Create or process the nfsTest.conf file (this will only return if it already exists)
    Platform.processConfFile()
    
    # Connect to just localhost to start with
    print ("")
    HostComm.addAHostConnection(0)
    
    # Verify pingability to all test hosts from the control host
    Platform.pingAllFromLocalhost()

    # Now connect to all the test hosts
    print ("")
    for hostRef in range(1, len(gHost_RowStatus)):
        HostComm.addAHostConnection(hostRef)
        
    time.sleep(1.5)
    
    # Present the menu and process user input - never return
    UI.coreInteractiveLogic()
        

""" - Help

    This is "Case Study 3" cited by the https://TestingComplexSystems.com web site.
    
    This presents a "test platform" that stands up and runs a number of "NFS" server 
    and client instances through their paces on three or more Linux test hosts. See 
    the "Case Study 3" tab on the above website for more information.

"""