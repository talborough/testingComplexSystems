#!/usr/bin/python3

""" - Status

+++ - nfsTest - Test a set of "NFS" instances

    V0104 - 02/12/2024 11:22 - More work on SMs and overall operation. Offline docs for this moment
    V0103 - 02/07/2024 12:01 - More work on SMs and overall operation. Improve documentation.
    V0102 - 02/04/2024 10:42 - It ran but the state machines needed major work. General cleanup as well.
    V0101 - 01/22/2024 09:20 - Fix up for webinars. Change the name of the generated support routines.
    V0100 - 01/04/2024 08:04 - Initial version entry.
    
    Plans:
    
        Update to support webinars.
    
---

"""

#
# nfsTest - An interactive "test platform" to run / test "NFS" on a number of Linux hosts.
#
# The file "nfsTest.conf" contains the attributes of the "hosts" being worked on (IP 
# address, login credentials, etc.) It's generated automatically when the code first runs 
# and it them must be filled out by the user.
#
# This code consumes the gDS definition file nfsTest.py (you must first use gDSCodeGen on nfsTest.dd):
#
#       ../gDS/gDSCodeGen nfsTest             >>>>>> gDSCodeGen uses nfsTest.dd to produce nfsTest.py
#
# Note that the below is not an OO implementation.
#
# There is help text at the bottom of this file for the user *or* (./nfsTest --help).
#
from multiprocessing import Process
import threading
from threading import Thread
from multiprocessing import Lock

import paramiko
import logging

import time
import sys
import os
import select
import random
import getopt


#
# Consume the gDS include file generated by gDSCodeGen if it exists and it's not out of date
#
if (not os.path.exists("./nfsTest.py")) or \
   (os.path.getmtime("./nfsTest.dd") >= os.path.getmtime("./nfsTest.py")):
    print ("")
    print ("./nfsTest.py does not exist or needs to be re-created with gDSCodeGen. Exiting.")
    print ("")
    sys.exit(1)
    
exec (open('nfsTest.py').read())


#
# Help control concurrent access to table rows.
#
class MasterLock:

    lockObject = Lock()

    def lock():
        
        MasterLock.lockObject.acquire()
        return
        
    def unlock():
    
        MasterLock.lockObject.release()
        return


#
# This supports extracting in-line text blocks at run time.
# It's good for templates and "help" blocks.
#
class InLineText:

    codeLines = []

    def getCodeLines():
    
        InLineText.codeLines = open(sys.argv[0], "r").read().splitlines()


    def getText(tag, substitutionList = []):

        lineRef = 0
        harvestingText = False
        harvestedText = ''

        while lineRef <= len(InLineText.codeLines):

            line = InLineText.codeLines[lineRef]
            lineRef += 1

            if (not harvestingText) and ('""" - ' in line):
                indent = line.find('"""')
                line = line[indent:]
                line = line.replace('""" - ', "")
                if line == tag:
                    harvestingText = True
                    
            elif (not harvestingText) and (lineRef == len(InLineText.codeLines)):
                print ("")
                print ("Can not find in-line text tag '%s'" % (tag))
                print ("Dividing by zero to dump call stack")
                print ("")
                x = 1/0

            elif harvestingText and ('"""' in line):
                return (harvestedText % (substitutionList))
                
            elif harvestingText:
                harvestedText += line[indent:] + "\n"

        return
        
        
#
# Screen color codes
# 
class Color:

    RED = "\u001b[31m"
    GREEN = "\u001b[32m"
    YELLOW = "\u001b[33m"
    BLUE = "\u001b[34m"
    MAGENTA = "\u001b[35m"
    CYAN = "\u001b[36m"
    WHITE = "\u001b[37m"


#
# This class supports communication between the Control Host / localhost (the host this
# code runs on) and the Test Hosts using Paramiko (ssh). It's used to execute commands
# on the test hosts as needed, before a test is run.
#
# NOTE: The control host / localhost connection is "good" all the time. However once a
# test run has started test host communication starts using the code in the Configurator
# class to do I/O.
#
class HostComm:

    # The connection to the control host for getting things done (cleanup, install software etc.)
    controlHostConnection = None

    # This list of Paramiko connections parallels the gDS table gHost.
    testHostConnections = []
    
    # Execute on the local host with a check of the retcode
    def executeOnLocalhostWithCheck(command):

        (i, o, e) = HostComm.controlHostConnection.exec_command(command)

        retcode = o.channel.recv_exit_status()
        
        if retcode:
        
            print ("")
            print (f"retcode = {retcode}")
            print ("")
            print (f"Host = control / localhost")
            print ("")
            print (f"Command = {command}")
            print ("")
            print (o.read().decode())
            print ("")
            print (f"stderr = {e.read().decode()}")
            print ("")
            print (f"retcode = {retcode}")
            print ("")
            print (f"Dividing by zero to dump call stack")
            print ("")
            x = 1/0

    # Set up HostComm.testHostConnections[hostRef] instances for the hostRef passed in. 
    # This elaborate code is used only to configure and startup the platform. The 
    # "reconnectToHosts" routine is used after a host is rebooted by the cleanup routine 
    # "cleanall".
    def addATestHostConnection(hostRef):
    
        # Check that the 2 host lists are in sync
        if len(HostComm.testHostConnections) != hostRef:
            print ("")
            print ("Programming error - test host lists are not in sync - dumping call stack")
            x = 1/0

        try:

            HostComm.testHostConnections.append(paramiko.client.SSHClient())
            HostComm.testHostConnections[hostRef].set_missing_host_key_policy(paramiko.AutoAddPolicy())
            HostComm.testHostConnections[hostRef].connect(gHost_Identifier[hostRef], \
                username = gUsername[0], password = gPassword[0])
            
            # Get the IP and hostname of the host and set them in the gDS gHost table
            (i, o, e) = HostComm.executeOnOneHost(hostRef, "hostname -I")
            gHost_IP[hostRef] = o.read().decode().strip()
            (i, o, e) = HostComm.executeOnOneHost(hostRef, "hostname")
            gHost_Hostname[hostRef] = o.read().decode().strip()
            
            gHost_Name[hostRef] = f"host #{hostRef}"
            
            x = f"Create a paramiko ssh connection from localhost to {gHost_Name[hostRef]} / {gHost_Identifier[hostRef]} / {gHost_IP[hostRef]} / {gHost_Role[hostRef]} / {gHost_Hostname[hostRef]}"
            print (x)
            logging.info(x)

        except Exception as e:
        
            print ("")
            print (e)
            logging.info(f"{e}")
            print ("Check that the ssh server is installed and running (see nfsTest.conf file for directions)")
            print ("")
            sys.exit(1)
                
        return
        
    # Reconnect any hosts rebooting during a "cleanall" command
    def reconnectRebootingTestHosts():

        # Look at all test hosts
        for hostRef in range(len(gHost_RowStatus)):
            
            # If no active host connection
            tempConnection = None
            while HostComm.testHostConnections[hostRef] is None:
        
                print (f" Try to reconnect to {gHost_Name[hostRef]}")
            
                try:

                    tempConnection = paramiko.client.SSHClient()
                    tempConnection.set_missing_host_key_policy(paramiko.AutoAddPolicy())
                    tempConnection.connect(gHost_IP[hostRef], \
                        username = gUsername[0], password = gPassword[0])
                    
                    HostComm.testHostConnections[hostRef] = tempConnection
                    print (f" Connected to {gHost_Name[hostRef]}")
                    time.sleep(1)

                except Exception as e:
                
                    time.sleep(5)
                
    def putFile (hostRef, src, dest):
 
        ftp_client = HostComm.testHostConnections[hostRef].open_sftp()
        ftp_client.put(src, dest)
        ftp_client.close()
        
        return

    def getFile (hostRef, src, dest):
 
        ftp_client = HostComm.testHostConnections[hostRef].open_sftp()
        ftp_client.get(src, dest)
        ftp_client.close()
        
        return

    # Execute a command on a host and return the result "(i, o, e)"
    def executeOnOneHost(hostRef, command):
    
        return HostComm.testHostConnections[hostRef].exec_command(command)

    # Execute a command on a host with a wait and return the result "(i, o, e)"
    def executeOnOneHostWithWait(hostRef, command):
    
        time.sleep(0.2)
    
        return HostComm.testHostConnections[hostRef].exec_command(command)

    # Execute a command on a host and return the result of "(i, o, e)" unless the command failed
    def executeOnOneTestHostWithCheck(hostRef, command):
    
        (i, o, e) = HostComm.testHostConnections[hostRef].exec_command(command)

        retcode = o.channel.recv_exit_status()
        
        if retcode:
        
            print ("")
            print (f"retcode = {retcode}")
            print ("")
            print (f"Host = #{hostRef}")
            print ("")
            print (f"Command = {command}")
            print ("")
            print (o.read().decode())
            print ("")
            print (f"stderr = {e.read().decode()}")
            print ("")
            print (f"retcode = {retcode}")
            print ("")
            print (f"Output above from {gHost_Name[hostRef]} / {gHost_Identifier[hostRef]} / {gHost_IP[hostRef]} / {gHost_Hostname[hostRef]}")
            print ("")
            
            sys.exit(1)
            
        return (i, o, e)
        

    # Get a list of hosts to operate on from user input
    def getHostRefList(prompt):
    
        print ("")
        for hostRef in range(len(gHost_RowStatus)):
        
            print (" %d) - %20s %20s %20s" % (hostRef, gHost_Identifier[hostRef], gHost_IP[hostRef], gHost_Hostname[hostRef]))
            
        print ("")
        print (" 'all' = all; or, numbers separated by whitespace")
        print ("")
        
        selection = input(prompt)
        
        hostRefList = []
        if "all" in selection:
            hostRefList = range(0, len(gHost_RowStatus))
        else:
            selection = selection.split()
            for string in selection:
                hostRefList.append(int(string))
                
        return (hostRefList)


#
# General-purpose test platform-related activities
#
class Platform:

    #
    # The nfsTest.conf file template
    #
    
    """ - nfsTest.conf
    #
    # nfsTest.conf - Define what's needed to get the nfsTest "test platform" up and running.
    #
    
    # Hint: When creating the necessary VMs put consecutive 4-digit number at the end of the
    # VM names in  the hypervisor so the VM data files can be identified and deleted by hand if 
    # necessary (some hypervisors don't automatically delete VM data files when deleting the VM). 
    # Use the same number when specifying the 'hostname' so it shows up in the command line. Don't
    # reuse the numbers but instead keep incrementing them.

    # Next, when creating and setting up each of the control and test hosts, use the same privileged
    # username / password pair for all the systems. Doing it this way doesn't require ssh keys.
    
    # Finally, the ssh server package must be installed (by hand) on the control host and each of the test 
    # hosts systems defined below. After that we will be able to do everything else with nfsTest. To do the ssh 
    # install on each host:
    #
    #   sudo apt update                                 # Update the install libraries
    #   sudo apt install openssh-server                 # Install and start the ssh server
    #
    #   sudo systemctl status ssh                       # Show the status of the ssh server if necessary
    #
    # Provide (below) the username and password for all activities to use on the control host and test hosts.
    #
    
    username = <username with the sudo priv to be used accessing *all* host systems>
    password = <password to go with the above username>
    
    # Provide the IP address or resolvable DNS name of the test hosts:
    
    testhostIdentifier = <resolvable host name or ip #1>
    testhostIdentifier = <resolvable host name or ip #2>
    testhostIdentifier = <resolvable host name or ip #3>
    
    # These control the size and shape of the configuration being tested.

    serverCount = 1
    clientCount = 2
    
    exportFSPerHost = 2
    fsUserPerImportFS = 3

    """

    #
    # Get the ball rolling by creating or processing the nfsTest.conf file
    #
    def processConfFile():
    
        # Save here until we set up all gHosts below in this method
        serverCount = None
        clientCount = None
    
        # Create conf file if there is none then exit
        if not os.path.exists("nfsTest.conf"):
        
            fileDesc = open("nfsTest.conf", "w")
            fileDesc.write(InLineText.getText("nfsTest.conf"))
            fileDesc.close()
            print ("")
            print ("********************************************************")
            print ("We have just written the 'nfsTest.conf' file in the default directory")
            print ("where you can read and edit it.")
            print ("********************************************************")
            print ("")
            sys.exit(0)
        
        confLines = open("nfsTest.conf", "r").read().splitlines()
        
        lineIndex = 0

        while lineIndex < len(confLines):
        
            # Get next line
            line = confLines[lineIndex]
        
            # Split off any comment
            if "#" in line:
                (line, dummy) = line.split("#", 1)
                
            # If something left it's hopefully "key = value"
            if line != "":
                
                # Split what's left by whitespace
                lineBits = line.split()
                
                if (len(lineBits) != 3) or (lineBits[1] != "="):
                    print ("")
                    print (f"Bad line in nfsTest.conf file at line {lineIndex + 1}")
                    print ("")
                    print (f"Line = {confLines[lineIndex]}")
                    print ("")
                    sys.exit(1)
                    
                # Set common username
                if lineBits[0] == "username":
                    gUsername[0] = lineBits[2]
                
                # Set common password
                elif lineBits[0] == "password":
                    gPassword[0] = lineBits[2]
                
                # Add another host to the list
                elif lineBits[0] == "testhostIdentifier":
                
                    # If we still need hosts
                    if len(gHost_RowStatus) < (serverCount + clientCount):
                
                        # Add a row; roles are set below after parsing all of the nfsTest.conf file
                        gHost_AddARow(_Identifier = lineBits[2])
                        logging.info(f"Adding a gHost row for {lineBits[2]}")
                        
                    else:
                    
                        print ("")
                        print (f"Ignoring extra 'testhostIdentifier' {lineBits[2]} line")

                elif lineBits[0] == "serverCount":
                    serverCount = int(lineBits[2])
                    
                elif lineBits[0] == "clientCount":
                    clientCount = int(lineBits[2])

                elif lineBits[0] == "exportFSPerHost":
                    Configurator.exportFSPerHost = int(lineBits[2])

                elif lineBits[0] == "fsUserPerImportFS":
                    Configurator.fsUserPerImportFS = int(lineBits[2])
                    
                else:
                
                    print ("")
                    print (f"Unknown keyword {lineBits[0]} in nfsTest.conf at line {lineIndex + 1}. Exiting.")
                    print ("")
                    sys.exit(1)                    
                    
            # Bump line pointer
            lineIndex += 1
            
        # The contrl gHost row has been made above; set server and client host roles
        
        # Make sure we have enough hosts to satisfy the server and client counts in the nfsTest.conf file
        if (serverCount + clientCount) > len(gHost_RowStatus):
            print ("")
            print (" The nfsTest.conf file doesn't specify enough hosts to fit the server and client counts also specified in it.")
            print (" Exiting.")
            print ("")
            sys.exit(1)
        
        hostRef = 0
        for i in range(serverCount):
            gHost_Role[hostRef] = "Server"
            hostRef += 1

        for i in range(clientCount):
            gHost_Role[hostRef] = "Client"
            hostRef += 1

        return

    # Ping out to all hosts from the control host / localhost
    def pingAllFromLocalhost():
    
        print ("")
        
        for hostRef in range(0, len(gHost_RowStatus)):

            print (f"Ping from 'localhost' to {gHost_Identifier[hostRef]}")
            HostComm.executeOnLocalhostWithCheck(f"ping {gHost_Identifier[hostRef]} -c 1")
            
        return

    #
    # Put the necessary software on any test host.
    #
    # !! Reload NFS server !!
    """ - Package installs
    
    sudo -S apt -y update
    sudo -S apt -y install python3-pip
    sudo -S apt -y install nfs-kernel-server
    sudo -S systemctl restart nfs-kernel-server
    sudo -S systemctl status ssh
    
    """

    """ - File copies
    
    appendALine         # Make executable
    removeALine         # Make executable
    ioEngine            # Make executable
    
    """
    
    #
    # Load necessary packages and copy necessary files onto the test host(s)
    #
    def loadSWOnTestHosts():
    
        # Get the lists above
        packageLoadList = InLineText.getText("Package installs").splitlines()
        fileCopyList = InLineText.getText("File copies").splitlines()
        
        hostRefList = HostComm.getHostRefList("Enter the test hosts to load the necessary pagkages and files onto: ")
            
        if len(hostRefList):

            print ("")
            
            for hostRef in hostRefList:
                
                for command in packageLoadList:
                
                    if command:
                
                        command = f"echo {gPassword[0]} | {command}"
                    
                        print ("")
                        print ("")
                        print (f"Execute '{command}' on test {gHost_Name[hostRef]}")
                        (i, o, e) = HostComm.executeOnOneTestHostWithCheck(hostRef, command)
                        print ("=================")
                        print (o.read().decode())
                        print ("=================")

                print ("")
                
                # Do file copies
                for file in fileCopyList:
                
                    if file:
                    
                        fileToCopy = file.strip()
                        makeExecutable = False
                        if "executable" in file:
                            (fileToCopy, dummy) = file.split("#")
                            fileToCopy = fileToCopy.strip()
                            makeExecutable = True

                        print (f"Copy ./{fileToCopy} to test {gHost_Name[hostRef]}")
                        HostComm.putFile(hostRef, f"./{fileToCopy}", f"./{fileToCopy}")
                        
                        if makeExecutable:
                            print ("Make the above file executable")
                            (i, o, e) = HostComm.executeOnOneTestHostWithCheck(hostRef, f"chmod 0755 ./{fileToCopy}")
                            
                print ("")

        print ("")
        input (" Hit Enter to continue: ")

        return


#
# The UI class houses code that gives the UI its look and feel, that starts a run "on its way", that
# monitors the run's progress.
#
class UI:

    # Track firt execution so we can ask to "cleanall"
    firstTime = True

    dumpToFile = False

    # Help the user remember what they have been doing
    lastCommand = []
    lastCommand.append("<none>")
    lastCommand.append("<none>")
    lastCommand.append("<none>")
    lastCommand.append("<none>")
    lastCommand.append("<none>")
    lastCommand.append("<none>")

    # The currently displaying screen (we only have one)
    displayName = "configuratorStates"
    
    # 
    # Clean the nfs test hosts entirely from wthe artifacts found on them
    #
    def cleanAll():
    
        def cleanIt():
    
            #
            # Stop and clean up nfsTest artifacts
            # Do not use any gDS data
            # Use only artifacts found on the hosts
            #
            # Kill any processes using the client mount points so the unmounts work
            #
            for hostRef in range(len(gHost_RowStatus)):
                (i, o, e) = HostComm.executeOnOneHostWithWait(hostRef, \
                        f"echo {gPassword[0]} | sudo -S lsof -N | grep 'nfsTest\|ioEngine'")
                lsofLines = o.read().decode().splitlines()
                for lsofLine in lsofLines:
                    process = lsofLine.split()[0]
                    pid = lsofLine.split()[1]
                    mntPoint = lsofLine.split()[-2]
                    print (f" Kill process '{process}' / '{pid}' using '{mntPoint}' on {gHost_Name[hostRef]}")
                    HostComm.executeOnOneHostWithWait(hostRef, \
                        f"echo {gPassword[0]} | sudo -S kill -9 {pid}")
                        
            time.sleep(2)

            #
            # Unmount all nfsTest client shares on all hosts
            #
            for hostRef in range(len(gHost_RowStatus)):
                (i, o, e) = HostComm.executeOnOneHostWithWait(hostRef, "df")
                dfLines = o.read().decode().splitlines()
                for dfLine in dfLines:
                    if "nfsTest" in dfLine:
                        dfMountpoint = dfLine.split()[-1]
                        print (f" Unmount '{dfMountpoint}' on {gHost_Name[hostRef]}")
                        HostComm.executeOnOneHostWithWait(hostRef, \
                            f"echo {gPassword[0]} | sudo -S umount {dfMountpoint}")
                print (f" Clean out '/etc/fstab' on {gHost_Name[hostRef]}")
                HostComm.executeOnOneHostWithWait(hostRef, \
                    f"echo {gPassword[0]} | sudo -S ./removeALine /etc/fstab nfsTest")

            # Un-export all nfsTest shares, restart the servers and delete the shared directories
            for hostRef in range(len(gHost_RowStatus)):
                print (f" Clean '/etc/exports' file on {gHost_Name[hostRef]}")
                HostComm.executeOnOneHostWithWait(hostRef, \
                    f"echo {gPassword[0]} | sudo -S ./removeALine /etc/exports nfsTest")
                print (f" Restart NFS server on {gHost_Name[hostRef]}")
                HostComm.executeOnOneHostWithWait(hostRef, \
                    f"echo {gPassword[0]} | sudo -S systemctl restart nfs-kernel-server")
                print (f" Delete '/var/nfsTest/*' on {gHost_Name[hostRef]}")
                HostComm.executeOnOneHostWithWait(hostRef, \
                    f"echo {gPassword[0]} | sudo -S rm -rf /var/nfsTest")
                print (f" Delete '/nfsTest/*' on {gHost_Name[hostRef]}")
                HostComm.executeOnOneHostWithWait(hostRef, \
                    f"echo {gPassword[0]} | sudo -S rm -rf /nfsTest")
                    
            return

        print ("")
        
        # Make first pass through cleaning defined above
        cleanIt()

        # See if any directories with stale file handles exist and reboot the host if so
        cleanAgain = False
        print ("")
        for hostRef in range(len(gHost_RowStatus)):
            print (f" Check for populated '/nfsTest' (client mount) directories on {gHost_Name[hostRef]}")
            (i, o, e) = HostComm.executeOnOneHostWithWait(hostRef, \
                f"echo {gPassword[0]} | sudo -S ls -al /nfsTest")
            output = o.read().decode()
            print (output)

            if output:

                print (f" Reboot {gHost_Name[hostRef]}")
                print ("")

                HostComm.executeOnOneHostWithWait(hostRef, \
                    f"echo {gPassword[0]} | sudo -S shutdown -r now")

                HostComm.testHostConnections[hostRef] = None
                cleanAgain = True
                
        time.sleep(1)
        HostComm.reconnectRebootingTestHosts()
            
        if cleanAgain:
            cleanIt()
            
        if not gScriptRunning[0]:
            print ("")
            input (" Hit Enter to continue: ")

    # Process user input
    def processCommand(command):
    
        UI.pushIntoCommandList(command)
    
        # Help
        if command == "help":
        
            print (InLineText.getText("Help"))
            input (" Enter <CR> to continue: ")
            
            
        elif command == "cleanall":

            MasterLock.lock()

            UI.cleanAll()

            MasterLock.unlock()


        elif command == "put":
        
            HostComm.putFile(int(input(" hostRef: ")), input("Src: "), input("Dest: "))


        elif command == "get":
        
            HostComm.getFile(int(input(" hostRef: ")), input("Src: "), input("Dest: "))

            
        # Execute command(s) on user-selectable hosts
        elif command == "ecmd":
        
            hostRefList = [None, None]
            
            while len(hostRefList):
        
                hostRefList = HostComm.getHostRefList("Enter where to execute the command(s): ")
                
                if len(hostRefList):
                
                    command = "dummy"
                    
                    while command:

                        print ("+++")
                        print ("systemctl status ssh")
                        print ("---")
                        command = input (" Enter the command to execute remotely: ")
                        command = command.strip()

                        if command:
                            for hostRef in hostRefList:
                                (i, o, e) = HostComm.executeOnOneHost(hostRef, command.strip())
                                print ("")
                                print ("retcode = ", o.channel.recv_exit_status())
                                print ("==================")
                                print (o.read().decode())
                                print ("==================")
                                print (f"stderr = {e.read().decode()}")
                                print ("")
                                print ("retcode = ", o.channel.recv_exit_status())
                                print ("")
                                print (f"Output from {gHost_Name[hostRef]} / {gHost_Identifier[hostRef]} / {gHost_IP[hostRef]} / {gHost_Hostname[hostRef]}")
                                print ("")


        # Install necessary software packages on selected hosts
        elif command == "insw":
        
            Platform.loadSWOnTestHosts()


        # Process "start all SMs" command
        elif command == "ss":

            if len(gExportFS_RowStatus):
                print ("")
                print (" Can't start all state machines once")
                print ("")
                time.sleep(4)
            else:

                # Define all gDS SM rows
                Configurator.createAllSMRows()
                # Start a process per host row and then start a thread per SM row
                Configurator.startAConfiguratorProcessesPerHost()


        # Move all SMs to Activating SMs to start
        elif command[0:3] == "aa":
        
            MasterLock.lock()
            
            Configurator.activateAllInactiveResources()

            MasterLock.unlock()


        # Reboot a host. gHost threads do the actual work.
        elif command[0:3] == "rh ":
        
            MasterLock.lock()
            args = command.split()
            if len(args) == 2:
                if gHost_State[int(args[1])] == "Active":
                    gHost_State[int(args[1])] = "Rebooting"
            MasterLock.unlock()
            

        # Force a data compare error on a given host's FSUser SM
        elif command[0:3] == "ff ":
        
            MasterLock.lock()
            args = command.split()
            if len(args) == 2:
                hostRef = int(args[1])
                gHost_ForceDataCompareError[hostRef] = True
            MasterLock.unlock()
            

        # Start a thread to Deactivate a given host. The thread spawned below does the actual work.
        elif command.startswith("dea "):
        
            MasterLock.lock()
            
            args = command.split()
            if len(args) == 2:
                hostRef = int(args[1])
                if Configurator.perHostDeactivatorThreads[hostRef] != None:
                    print ("")
                    print (" A Deactivate is currently underway on this host")
                    print ("")
                    time.sleep(4)
                else:
                    Configurator.perHostDeactivatorThreads[hostRef] = Thread(target = \
                        Configurator.deactivateHost, \
                        name = gHost_Name[hostRef] + " deactivate host thread" , \
                        args = [hostRef,])
                    Configurator.perHostDeactivatorThreads[hostRef].start()
                    
            MasterLock.unlock()


        # Start a thread to Deactivate a given host. The thread spawned below does the actual work.
        elif command.startswith("script "):
        
            MasterLock.lock()
            
            gScriptRunning[0] = True
            
            args = command.split()
            if len(args) == 2:
                fileName = args[1]

            # Get the input file as a list of lines
            inLines = open(fileName + ".scr", "r").read().splitlines()
            gScriptFileName[0] = fileName + ".scr"

            Configurator.scriptThread = Thread(target = Configurator.scriptEngine, \
                name = "Script engine", args = [inLines,])
            Configurator.scriptThread.start()
                    
            MasterLock.unlock()
            
        # Wait for host to go Active
        elif command.startswith("waa "):

            MasterLock.lock()
            
            args = command.split()
            if len(args) == 2:
                hostRef = int(args[1])
                while gHost_State[hostRef] != "Active":
                
                    MasterLock.unlock()
                    time.sleep(5)
                    MasterLock.lock()

            MasterLock.unlock()


        # Wait for host to go Inactive
        elif command.startswith("wai "):

            MasterLock.lock()
            
            args = command.split()
            if len(args) == 2:
                hostRef = int(args[1])
                while gHost_State[hostRef] != "Inactive":
                
                    MasterLock.unlock()
                    time.sleep(5)
                    MasterLock.lock()

            MasterLock.unlock()


        # Wait some time
        elif command.startswith("wait "):

            args = command.split()
            if len(args) == 2:
                sleepTime = int(args[1])
                time.sleep(sleepTime)


        # Activate an Inactive host as a client or server
        elif command.startswith("acts ") or command.startswith("actc "):
        
            MasterLock.lock()
            
            args = command.split()
            if len(args) == 2:
                hostRef = int(args[1])
                if gHost_State[hostRef] == "Inactive":
                
                    if command.startswith("actc "):
                        gHost_Role[hostRef] = "Client"
                    else:
                        gHost_Role[hostRef] = "Server"
                    
                    gHost_State[hostRef] = "Activating"

            MasterLock.unlock()

             
        # Set dump output
        elif command == "dtf":
            UI.dumpToFile = True
            input(" The output files will be the same name as the dump commands: ")


        # Set dump output
        elif command == "dts":
            UI.dumpToFile = False


        # Dump host rows
        elif command == "dhr":
            if UI.dumpToFile:
                gHost_DumpRows(outFile = open("dhr", "w"))
            else:
                gHost_DumpRows()
            print ("")
            input (" Hit Enter to continue from the dump: ")

            
        # Dump ExportFS rows
        elif command == "der":
            if UI.dumpToFile:
                gExportFS_DumpRows(outFile = open("der", "w"))
            else:
                gExportFS_DumpRows()
            print ("")
            input (" Hit Enter to continue from the dump: ")

            
        # Dump ImportFS rows
        elif command == "dir":
            if UI.dumpToFile:
                gImportFS_DumpRows(outFile = open("dir", "w"))
            else:
                gImportFS_DumpRows()
            print ("")
            input (" Hit Enter to continue from the dump: ")

            
        # Dump FSUser rows
        elif command == "dur":
            if UI.dumpToFile:
                gFSUser_DumpRows(outFile = open("dur", "w"))
            else:
                gFSUser_DumpRows()
            print ("")
            input (" Hit Enter to continue from the dump: ")

            
        else:
            print ("")
            print (f"Invalid command: '{command}'")
            time.sleep(4)

        return


    # Service the updating of the terminal screen
    def serviceTerminal():
    
        startTime = time.time()
        
        MasterLock.lock()
        
        displayLines = "\033[H\033[J \n"

        # Decide what display to show
        if UI.displayName == "configuratorStates":
        
            x = Color.RED
            y = Color.WHITE
            
            displayLines += f" Uptime: {int(time.time() - gStartTime[0])} secs; "
            displayLines += f" exportFSPerHost = {Configurator.exportFSPerHost}; "
            displayLines += f" fsUserPerImportFS = {Configurator.fsUserPerImportFS}; "
            displayLines += f" Deactivator counts = {Configurator.deactivatorThreadCount}; "
            displayLines += f" Lock pull time: {int((time.time() - startTime) * 1000)} ms \n"

            displayLines += " \n"
            displayLines += Configurator.generateRowStatisticsDisplay()
            
            MasterLock.unlock()
            
            # Update menu
            displayLines += " \n"
            displayLines += " dhr / der / dir / dur = Dump hosts / exportFS / importFS / FSUser rows \n"
            displayLines += " insw / cleanall       = Install sw / clean test hosts \n"
            displayLines += " ecmd / dtf/dts        = Execute command(s) on test host(s) / dump to screen/file \n"
            displayLines += " ss / aa / script ...  = Start all SMs / activate all SMs / run script \n"
            displayLines += " rh n / ff n           = Reboot host n / force data compare fault host n \n"
            displayLines += " dea n / acts/c n      = Deactivate host n / activate host svr/cli n \n"
            displayLines += " waa n / wai n / wait  = Wait for Active / Inactive host / just wait seconds \n"
            displayLines += " help                  = Print help on the screen \n"
            displayLines += " \n"
            displayLines += f" Command #0 .. #5 = '{UI.lastCommand[0]}' | '{UI.lastCommand[1]}' | '{UI.lastCommand[2]}' | '{UI.lastCommand[3]}' | '{UI.lastCommand[4]}' | '{UI.lastCommand[5]}' \n"
    
            # Print whole screen with one "print" (no flashing)
            print (displayLines)

            if (time.time() - gStartTime[0]) > 1200:
                print ("")
                print ("Stopping after 20 minutes so we don't consume a lot of disk space in nfsTest.log.")
                print ("")
                gAllStop[0] = True
                time.sleep(100000)            

            if UI.firstTime:
                # Maybe clean the test hosts the first time through this code
                print ("")
                answer = input(" Enter 'y' to 'clean all' test hosts: ")
                if answer == "y":
                    UI.processCommand("cleanall")
                print ("")
                # Maybe create and start all state machines the first time through this code
                print ("")
                answer = input(" Enter 'y' to 'ss': ")
                if answer == "y":
                    UI.processCommand("ss")
                print ("")
                answer = input(" Enter 'y' to 'aa': ")
                if answer == "y":
                    UI.processCommand("aa")
                print ("")

            i = ""
            if gScriptRunning[0]:
                print (f" Script details: [{gScriptFileName[0]}: {gScriptCurrentLineNumber[0]}/{gScriptMaxLineNumber[0]} - {gScriptCommand[0]}]")
                print ("")
                time.sleep(2)
            elif UI.firstTime:
                time.sleep(2)
            else:# Get any user input and also pause for 2 seconds
                print (f" Type a command from the menu above then hit Enter:")
                i, o, e = select.select([sys.stdin], [], [], 2)

            # No longer the first time
            UI.firstTime = False
            
            # If some input
            if i:
                
                command = sys.stdin.readline().strip()
                
                # Process user input
                UI.processCommand(command)
            
        return
        
    def pushIntoCommandList(command):
    
        UI.lastCommand[5] = UI.lastCommand[4]
        UI.lastCommand[4] = UI.lastCommand[3]
        UI.lastCommand[3] = UI.lastCommand[2]
        UI.lastCommand[2] = UI.lastCommand[1]
        UI.lastCommand[1] = UI.lastCommand[0]
        UI.lastCommand[0] = command
        
        return


    # Watch/control what's going on from the display rendered on the terminal
    def coreInteractiveLogic():
    
        Configurator.defineDeactivatorThreadList()
    
        # Always update the screen
        while not gAllStop[0]:

            # Update screen and process any user input
            UI.serviceTerminal()
            
            # Manage what "main" starts            
            Configurator.completeBackgroundUIActivities()

        # Hang if a problem occurs
        time.sleep(100000)


class Configurator:

    # Must be mindful of the process / thread contexts these are being used in
    perHostSMManagementProcesses = []           # Spawned from the above process (in startAConfiguratorProcessesPerHost)
    smThreads = []                              # Spawned from the above processes (in startAllSMThreads)
    testHostConnections = []                    # Per host, per thread Paramiko connection
    perHostDeactivatorThreads = []              # Each thread is run against a host
    deactivatorThreadCount = None               # To advertize in the display
    
    scriptThread = None                         # The script engine runs on this
    
    # These are set by entries in the nfsTest.conf file. They control the size and shape
    # of the configuration being tested and the rate at which it operates
    exportFSPerHost = None
    fsUserPerImportFS = None

    # Wait time per SM thread (randomized at point of use)
    secondsPerStateTransition = 5

    # Script engine thread code
    def scriptEngine(inLines):
    
        gScriptMaxLineNumber[0] = len(inLines)
    
        # For each line
        lineNumber = 0
        for inLine in inLines:
            lineNumber += 1
        
            if "#" in inLine:
                (inLine, dummy) = inLine.split("#", 1)

            inLine = inLine.strip()
            if inLine:
            
                gScriptCurrentLineNumber[0] = lineNumber
                gScriptCommand[0] = inLine
                UI.processCommand(inLine)
            
        gScriptRunning[0] = False

        return


    # Activate all Inactive SMs
    def activateAllInactiveResources():
    
        for hostRef in range(len(gHost_RowStatus)):
            if gHost_State[hostRef] == "Inactive":
                gHost_State[hostRef] = "Activating"
    
        for exportFSRef in range(len(gExportFS_RowStatus)):
            if gExportFS_State[exportFSRef] == "Inactive":
                gExportFS_State[exportFSRef] = "Activating"
    
        for importFSRef in range(len(gImportFS_RowStatus)):
            if gImportFS_State[importFSRef] == "Inactive":
                gImportFS_State[importFSRef] = "Activating"
    
        for fsUserRef in range(len(gFSUser_RowStatus)):
            if gFSUser_State[fsUserRef] == "Inactive":
                gFSUser_State[fsUserRef] = "Activating"
    
        return
            
    # Define the list that holds the Deactivator Thread objects
    def defineDeactivatorThreadList():
    
        for hostRef in range(len(gHost_RowStatus)):
            Configurator.perHostDeactivatorThreads.append(None) 
            
        return

    # Complete any background Configurator activities off of the main thread
    def completeBackgroundUIActivities():
    
        # Just count active deactivator threads
        Configurator.deactivatorThreadCount = 0
    
        # Look for and complete any deactivator threads
        for hostRef in range(len(Configurator.perHostDeactivatorThreads)):
            if Configurator.perHostDeactivatorThreads[hostRef] is not None:
                if Configurator.perHostDeactivatorThreads[hostRef].is_alive():
                    Configurator.deactivatorThreadCount += 1
                else:
                    Configurator.perHostDeactivatorThreads[hostRef].join()
                    Configurator.perHostDeactivatorThreads[hostRef] = None
                    
    #
    # Keep trying to connect to the host if necessary and then communicate with it
    #
    def talkToHost(hostConnRef, hostRef, command, stopOnError = True):
    
        # If there's no active host connection keep trying to get one
        while Configurator.testHostConnections[hostConnRef] is None:

            logging.info(f"Trying to connect to {gHost_Name[hostRef]} using {hostConnRef}; {command}")
    
            try:

                tempConnection = paramiko.client.SSHClient()
                tempConnection.set_missing_host_key_policy(paramiko.AutoAddPolicy())
                tempConnection.connect(gHost_IP[hostRef], username = gUsername[0], password = gPassword[0])
                
                Configurator.testHostConnections[hostConnRef] = tempConnection

            except Exception as e:
            
                time.sleep(1)
            
        # We're in - talk...
        (i, o, e) = Configurator.testHostConnections[hostConnRef].exec_command(command)

        retcode = o.channel.recv_exit_status()
        
        if retcode:
        
            logging.info(f"Execute on {gHost_Name[hostRef]}; {command} has a retcode !!!!!!!!!!!!!!!!!!!!")
            logging.info(f"Execute on {gHost_Name[hostRef]}; {command} has a retcode !!!!!!!!!!!!!!!!!!!!")
            logging.info(f"Execute on {gHost_Name[hostRef]}; {command} has a retcode !!!!!!!!!!!!!!!!!!!!")

            logging.info("")
            logging.info(f"retcode = {retcode}")
            logging.info("")
            logging.info(f"Host = #{hostRef}")
            logging.info("")
            logging.info(f"Command = {command}")
            logging.info("")
            logging.info(o.read().decode())
            logging.info("")
            logging.info(f"stderr = {e.read().decode()}")
            logging.info("")
            
            if stopOnError:
                print ("")
                print (f"Stopping after getting a command error on host #{hostRef}.")
                print ("See nfsTest.log for details.")
                print ("")
                gAllStop[0] = True
                time.sleep(100000)            

        return (o.read().decode(), e.read().decode(), retcode)

    # Count States from all SM rows
    def countRowStates():
    
        gHostInactive[0] = gHost_State.count("Inactive")
        gHostActivating[0] = gHost_State.count("Activating")
        gHostActive[0] = gHost_State.count("Active")
        gHostDeactivating[0] = gHost_State.count("Deactivating")
        gHostRebooting[0] = gHost_State.count("Rebooting")
    
        gExportFSInactive[0] = gExportFS_State.count("Inactive")
        gExportFSActivating[0] = gExportFS_State.count("Activating")
        gExportFSActive[0] = gExportFS_State.count("Active")
        gExportFSDeactivating[0] = gExportFS_State.count("Deactivating")
        gExportFSRebooting[0] = gExportFS_State.count("Rebooting")
    
        gImportFSInactive[0] = gImportFS_State.count("Inactive")
        gImportFSActivating[0] = gImportFS_State.count("Activating")
        gImportFSActive[0] = gImportFS_State.count("Active")
        gImportFSDeactivating[0] = gImportFS_State.count("Deactivating")
        gImportFSRebooting[0] = gImportFS_State.count("Rebooting")
    
        gFSUserInactive[0] = gFSUser_State.count("Inactive")
        gFSUserActivating[0] = gFSUser_State.count("Activating")
        gFSUserActive[0] = gFSUser_State.count("Active")
        gFSUserDeactivating[0] = gFSUser_State.count("Deactivating")
        gFSUserRebooting[0] = gFSUser_State.count("Rebooting")
        
        return
            
    def generateRowStatisticsDisplay():

        Configurator.countRowStates()
    
        displayLines = " SM Row             Host     exportFS     importFS       FSUser \n"
        displayLines += " States            Count        Count        Count        Count \n"
        displayLines += " --------          -----     --------     --------       ------ \n"
        displayLines += " Inactive           %4d         %4d         %4d         %4d \n" % (gHostInactive[0], gExportFSInactive[0], gImportFSInactive[0], gFSUserInactive[0])
        displayLines += " Activating         %4d         %4d         %4d         %4d \n" % (gHostActivating[0], gExportFSActivating[0], gImportFSActivating[0], gFSUserActivating[0])
        displayLines += " Active             %4d         %4d         %4d         %4d \n" % (gHostActive[0], gExportFSActive[0], gImportFSActive[0], gFSUserActive[0])
        displayLines += " Deactivating       %4d         %4d         %4d         %4d \n" % (gHostDeactivating[0], gExportFSDeactivating[0], gImportFSDeactivating[0], gFSUserDeactivating[0])
        displayLines += " Rebooting          %4d         %4d         %4d         %4d \n" % (gHostRebooting[0], gExportFSRebooting[0], gImportFSRebooting[0], gFSUserRebooting[0])
        displayLines += " \n"
        displayLines += " SM Threads  >>>>   %4d         %4d         %4d         %4d \n" % (gHostSMThreadCount[0], gExportFSSMThreadCount[0], gImportFSSMThreadCount[0], gFSUserSMThreadCount[0])
        displayLines += " \n"
        
        displayLines += "                                                                     Norm  Abrt    OK  Prem Empty    No       \n"
        displayLines += " Per Host     Host          Host     ExportFS   ImportFS   FSUser     I/O  Conn   Vfy   EOF  File  File   Tot \n"
        displayLines += " Info         Role          State    Use Cnt    Use Cnt    Use Cnt    Cnt   Cnt   Cnt   Cnt   Cnt   Cnt   Cnt \n"
        displayLines += " -------      ----          -----    --------   --------   ------- ------  ----   ---------------------   --- \n"
        
        for hostRef in range(len(gHost_RowStatus)):
            displayLines += "%8s  %8s   %12s        %4d       %4d      %4d   %4d  %4d  %4d  %4d  %4d  %4d  %4d \n" % \
               (gHost_Name[hostRef], \
                gHost_Role[hostRef], \
                gHost_State[hostRef], \
                
                gHost_ExportFSUseCount[hostRef], \
                gHost_ImportFSUseCount[hostRef], \
                gHost_FSUserUseCount[hostRef], \
                
                gHost_OKWRCount[hostRef], \
                gHost_BadConnCount[hostRef], \
                gHost_OKVerifyCount[hostRef], \
                gHost_PrematureEOFCount[hostRef], \
                gHost_EmptyFileCount[hostRef], \
                gHost_MissingFileCount[hostRef], \
                
                gHost_OKVerifyCount[hostRef] + \
                gHost_PrematureEOFCount[hostRef] + 
                gHost_EmptyFileCount[hostRef] + \
                gHost_MissingFileCount[hostRef])


        return (displayLines)
    
    ###???
    def createAllSMRows():
    
        # gHost rows already exist...
    
        # Make all possible, legal export FS rows
        for hostRef in range(len(gHost_RowStatus)):
            for exportFSNum in range(Configurator.exportFSPerHost):

                exportFSRef = gExportFS_AddARow(_gHost_Ref = hostRef, \
                    _Name = f"host_{'%4.4x' %(hostRef)}_export_{'%4.4x' % (len(gExportFS_RowStatus))}")

                logging.info(f"Add export FS row for {gHost_Name[hostRef]}")

        # Make all possible, legal import FS rows for the export FS rows
        for hostRef in range(len(gHost_RowStatus)):
            for exportFSRef in range(len(gExportFS_RowStatus)):
                # Do not make imports that match exports
                if hostRef != gExportFS_gHost_Ref[exportFSRef]:
                
                    importFSRef = gImportFS_AddARow(_gHost_Ref = hostRef,
                        _gExportFS_Ref = exportFSRef,
                        _Name = f"host_{'%4.4x' % (hostRef)}_export_{'%4.4x' % (exportFSRef)}_import_{'%4.4x' % (len(gImportFS_RowStatus))}")
                        
                    logging.info(f"Add import FS row for {gHost_Name[hostRef]}, {gExportFS_Name[exportFSRef]}")
                
        # Make all possible, legal FS User rows to go up against the import FS rows
        for hostRef in range(len(gHost_RowStatus)):
            for importFSRef in range(len(gImportFS_RowStatus)):
                # Only make rows for FS users on the same host as the import
                if hostRef == gImportFS_gHost_Ref[importFSRef]:
                    for fsUserNum in range(Configurator.fsUserPerImportFS):

                        fsUserRef = gFSUser_AddARow(_gHost_Ref = hostRef,
                            _gExportFS_Ref = gImportFS_gExportFS_Ref[importFSRef],
                            _gImportFS_Ref = importFSRef,
                            _Name = f"host_{'%4.4x' % (gImportFS_gHost_Ref[importFSRef])}_export_{'%4.4x' % (gImportFS_gExportFS_Ref[importFSRef])}_import_{'%4.4x' % (importFSRef)}_user_{'%4.4x' % (len(gFSUser_RowStatus))}")

                        logging.info(f"Add FS user row for {gHost_Name[hostRef]}, {gImportFS_Name[importFSRef]}")

        return
    
    # Start one process per host; that process starts the 4 types of SM management threads
    def startAConfiguratorProcessesPerHost():
    
        MasterLock.lock()
        for hostRef in range(len(gHost_RowStatus)):
        
            Configurator.perHostSMManagementProcesses.append(Process(target = \
                Configurator.startAllSMThreads, \
                name = gHost_Name[hostRef] + " control process" , \
                args = [hostRef,]))
            Configurator.perHostSMManagementProcesses[-1].start()
            
        MasterLock.unlock()
        
    def startAllSMThreads(hostRef):
    
        #
        # We are a process on each host so now make all the necessary control threada (per host)
        # NOTE: See the host connection index as the second argument. It's NOT a gDS variable but
        # a per thread variable.
        #
        MasterLock.lock()
        
        # Start a manage host thread
        Configurator.testHostConnections.append(None)
        Configurator.smThreads.append(Thread(target = Configurator.manageHostSM, \
            name = gHost_Name[hostRef], \
            args = [hostRef, len(Configurator.testHostConnections) - 1]))
        gHostSMThreadCount[0] += 1
        Configurator.smThreads[-1].start()

        # Iterate over export FS rows that cite this thread's host
        for exportFSRef in range(len(gExportFS_RowStatus)):
            if gExportFS_gHost_Ref[exportFSRef] == hostRef:
                Configurator.testHostConnections.append(None)
                Configurator.smThreads.append(Thread(target = Configurator.manageExportFSSM, \
                     name = gExportFS_Name[exportFSRef], \
                     args = [exportFSRef, len(Configurator.testHostConnections) - 1]))
                gExportFSSMThreadCount[0] += 1
                Configurator.smThreads[-1].start()

        # Iterate over import FS rows that cite this thread's host
        for importFSRef in range(len(gImportFS_RowStatus)):
            if gImportFS_gHost_Ref[importFSRef] == hostRef:
                Configurator.testHostConnections.append(None)
                Configurator.smThreads.append(Thread(target = Configurator.manageImportFSSM, \
                    name = gImportFS_Name[importFSRef], \
                    args = [importFSRef, len(Configurator.testHostConnections) - 1]))
                gImportFSSMThreadCount[0] += 1
                Configurator.smThreads[-1].start()

        # Iterate over FS user rows that cite this thread's host
        for fsUserRef in range(len(gFSUser_RowStatus)):
            if gFSUser_gHost_Ref[fsUserRef] == hostRef:
                Configurator.testHostConnections.append(None)
                Configurator.smThreads.append(Thread(target = Configurator.manageFSUserSM, \
                    name = gFSUser_Name[fsUserRef], \
                    args = [fsUserRef, len(Configurator.testHostConnections) - 1]))
                gFSUserSMThreadCount[0] += 1
                Configurator.smThreads[-1].start()

        MasterLock.unlock()
        
        time.sleep(1)
       
    # The deactivator is a separate thread off the main process because we need the state 
    # machines and screen to be functional
    #
    # 1) Set the given host SM to Deactivating
    # 2) Wait for the host SM to go Inactive under partial lock
    # 3) Set all the dependent SMs to Activating under full lock
    # 
    def deactivateHost(hostRef):

        MasterLock.lock()

        if gHost_State[hostRef] == "Active":
        
            # Set host to Deactivating; all dependent SMs will stop first
            gHost_State[hostRef] = "Deactivating"
        
            # Wait for all its dependent SMs to stop (while sleeping unlocked)
            while gHost_State[hostRef] != "Inactive":
                MasterLock.unlock()
                time.sleep(1)
                MasterLock.lock()
                
            # Set all dependent resources Activating leave host Inactive
            Configurator.activateInactiveResources(hostRef)
            
            gHost_Role[hostRef] = "<none>"

        MasterLock.unlock()
            
        return
        
    def activateInactiveResources(hostRef):
    
        # If we are working on a Server
        if gHost_Role[hostRef] == "Server":
        
            # Get the exportedFS using the given server Activating
            for exportFSRef in range(len(gExportFS_RowStatus)):
                if gExportFS_gHost_Ref[exportFSRef] == hostRef:
                    gExportFS_State[exportFSRef] = "Activating"
                    # Get the importFS using the exportFS Activating
                    for importFSRef in range(len(gImportFS_RowStatus)):
                        if gImportFS_gExportFS_Ref[importFSRef] == exportFSRef:
                            gImportFS_State[importFSRef] = "Activating"
                            # Get the fsUSer using the importFS Activating
                            for fsUserRef in range(len(gFSUser_RowStatus)):
                                if gFSUser_gImportFS_Ref[fsUserRef] == importFSRef:
                                    gFSUser_State[fsUserRef] = "Activating"
        
        # Else working on a Client
        else:
        
            # On importFS on given hosts
            for importFSRef in range(len(gImportFS_RowStatus)):
                if gImportFS_gHost_Ref[importFSRef] == hostRef:
                    # Set to Activating
                    gImportFS_State[importFSRef] = "Activating"
                    # Get the fsUSer using the importFS Activating
                    for fsUserRef in range(len(gFSUser_RowStatus)):
                        if gFSUser_gImportFS_Ref[fsUserRef] == importFSRef:
                            gFSUser_State[fsUserRef] = "Activating"
                
        return

    def manageHostSM(hostRef, hostConnRef):
    
        while not gAllStop[0]:
        
            MasterLock.lock()
        
            # If activating a server
            if gHost_Role[hostRef] == "Server":

                if gHost_State[hostRef] == "Activating":
            
                    logging.info(f"Activate name = {gHost_Name[hostRef]}; role = {gHost_Role[hostRef]}; state = {gHost_State[hostRef]}")

                    gHost_State[hostRef] = "Active"
                    
                # If an active server, do nothing
                elif gHost_State[hostRef] == "Active":
                
                    pass

                # Reboot right away and wait for the connection to start working again
                elif gHost_State[hostRef] == "Rebooting":
                
                    Configurator.testHostConnections[hostConnRef] = None
                    #Configurator.talkToHost(hostConnRef, hostRef, \
                    #    f"echo {gPassword[0]} | sudo -S shutdown -r now", stopOnError = False)
                    Configurator.talkToHost(hostConnRef, hostRef, \
                        f"echo {gPassword[0]} | sudo -S reboot", stopOnError = False)
                        
                    time.sleep(3)

                    # Unlock so screen updates. No one messes with a Rebooting host.
                    MasterLock.unlock()
                    
                    Configurator.testHostConnections[hostConnRef] = None
                    Configurator.talkToHost(hostConnRef, hostRef, f"echo {gPassword[0]} | sudo -S date")

                    MasterLock.lock()
                    
                    gHost_State[hostRef] = "Active"
                        
                # If deactivating a server, first wait for its use counts to go to zero
                elif (gHost_State[hostRef] == "Deactivating") and \
                     (gHost_ExportFSUseCount[hostRef] == 0):

                    logging.info(f"Deactivate name = {gHost_Name[hostRef]}; role = {gHost_Role[hostRef]}; state = {gHost_State[hostRef]}")

                    gHost_State[hostRef] = "Inactive"

                # If unused server, do nothing
                elif (gHost_State[hostRef] == "Inactive"):
                
                    pass

            # If activating a client
            elif gHost_Role[hostRef] == "Client":
            
                if gHost_State[hostRef] == "Activating":
            
                    logging.info(f"Activate name = {gHost_Name[hostRef]}; role = {gHost_Role[hostRef]}; state = {gHost_State[hostRef]}")

                    gHost_State[hostRef] = "Active"
                    
                # If an active client, do nothing
                elif gHost_State[hostRef] == "Active":
                
                    pass

                # Reboot right away and wait for the connection to start working again
                elif gHost_State[hostRef] == "Rebooting":
                
                    Configurator.testHostConnections[hostConnRef] = None
                    #Configurator.talkToHost(hostConnRef, hostRef, \
                    #    f"echo {gPassword[0]} | sudo -S shutdown -r now", stopOnError = False)
                    Configurator.talkToHost(hostConnRef, hostRef, \
                        f"echo {gPassword[0]} | sudo -S reboot", stopOnError = False)
                        
                    time.sleep(3)

                    # Unlock so screen updates. No one messes with a Rebooting host.
                    MasterLock.unlock()
                    
                    Configurator.testHostConnections[hostConnRef] = None
                    Configurator.talkToHost(hostConnRef, hostRef, f"echo {gPassword[0]} | sudo -S date")

                    MasterLock.lock()
                    
                    gHost_State[hostRef] = "Active"
                        
                # If deactivating a client, first wait for its dependent use counts to go to zero
                elif (gHost_State[hostRef] == "Deactivating") and \
                     (gHost_ImportFSUseCount[hostRef] == 0) and \
                     (gHost_FSUserUseCount[hostRef] == 0):
                    
                    logging.info(f"Deactivate name = {gHost_Name[hostRef]}; role = {gHost_Role[hostRef]}; state = {gHost_State[hostRef]}")
                    
                    gHost_State[hostRef] = "Inactive"

                # If unused client, do nothing
                elif gHost_State[hostRef] == "Inactive":
                
                    pass

            # Unlock to wait in loop
            MasterLock.unlock()
        
            time.sleep(random.randrange(Configurator.secondsPerStateTransition))
            
        # If we get here just preserve state
        time.sleep(100000)

    # Implement export file system state machine
    def manageExportFSSM(exportFSRef, hostConnRef):
    
        serverHostRef = gExportFS_gHost_Ref[exportFSRef]

        def createExportFS():
        
            Configurator.testHostConnections[hostConnRef] = None
            Configurator.talkToHost(hostConnRef, serverHostRef, \
                f"echo {gPassword[0]} | sudo -S mkdir -p /var/nfsTest/{gExportFS_Name[exportFSRef]}")
            Configurator.talkToHost(hostConnRef, serverHostRef, \
                f"echo {gPassword[0]} | sudo -S chown -R nobody:nogroup /var/nfsTest")
                
            Configurator.talkToHost(hostConnRef, serverHostRef, \
                f"echo {gPassword[0]} | sudo -S ./appendALine /etc/exports '/var/nfsTest/{gExportFS_Name[exportFSRef]} *(rw,sync,no_subtree_check)'")

            Configurator.talkToHost(hostConnRef, serverHostRef, \
                f"echo {gPassword[0]} | sudo -S systemctl restart nfs-kernel-server")
                
            return

        def destroyExportFS():
        
            Configurator.testHostConnections[hostConnRef] = None
            Configurator.talkToHost(hostConnRef, serverHostRef, \
                f"echo {gPassword[0]} | sudo -S ./removeALine /etc/exports '/var/nfsTest/{gExportFS_Name[exportFSRef]} *(rw,sync,no_subtree_check)'")

            Configurator.talkToHost(hostConnRef, serverHostRef, \
                f"echo {gPassword[0]} | sudo -S systemctl restart nfs-kernel-server")
                
            Configurator.talkToHost(hostConnRef, serverHostRef, \
                f"echo {gPassword[0]} | sudo -S rm -rf /var/nfsTest/{gExportFS_Name[exportFSRef]}")
                
            return

        # ExportFS actions
        while not gAllStop[0]:

            MasterLock.lock()

            # If this exported FS belongs to a host that's a server type at this time
            if gHost_Role[serverHostRef] == "Server":
            
                # Host-led deactivation of an active, in use exportFS server host!!
                # If the server's host is Deactivating and the export FS is active and unused deactivate it
                if (gHost_State[serverHostRef] == "Deactivating") and \
                   (gExportFS_State[exportFSRef] == "Active") and \
                   (gExportFS_ImportFSUseCount[exportFSRef] == 0):
                   
                    destroyExportFS()

                    # Track exported FS use count
                    gHost_ExportFSUseCount[serverHostRef] -= 1
                    gExportFS_State[exportFSRef] = "Inactive"
                
                # If activating an exported FS and the server it is to run on is active
                elif (gExportFS_State[exportFSRef] == "Activating") and \
                   (gHost_State[serverHostRef] == "Active"):
               
                    # Make and export the FS
                    logging.info(f"Activate Export FS #{exportFSRef}; host = {gHost_Name[serverHostRef]}; name = {gExportFS_Name[exportFSRef]}; state = {gExportFS_State[exportFSRef]}")
                    
                    createExportFS()

                    # Track exported FS use count
                    gHost_ExportFSUseCount[serverHostRef] += 1
                    gExportFS_State[exportFSRef] = "Active"
                
                # If managing an active exported FS; do nothing
                elif gExportFS_State[exportFSRef] == "Active":
               
                    # Do nothing
                    pass
                
                # If deactivating an exported FS and its use count is zero
                elif (gExportFS_State[exportFSRef] == "Deactivating") and \
                     (gExportFS_ImportFSUseCount[exportFSRef] == 0):
               
                    # Destroy the exported FS
                    logging.info(f"Deactivate Export FS #{exportFSRef}; name = {gExportFS_Name[exportFSRef]}; state = {gExportFS_State[exportFSRef]}")
                    
                    destroyExportFS()

                    # Track exported FS and backing host
                    gHost_ExportFSUseCount[serverHostRef] -= 1
                    gExportFS_State[exportFSRef] = "Inactive"
                
                # If managing an unused exported FS; do nothing
                elif gExportFS_State[exportFSRef] == "Inactive":
               
                    # Do nothing
                    pass

            # Unlock to wait in loop
            MasterLock.unlock()
    
            time.sleep(random.randrange(Configurator.secondsPerStateTransition))
            
        time.sleep(100000)
        
    # Implement import file system state machine
    def manageImportFSSM(importFSRef, hostConnRef):

        # Get refs of who we are using
        clientHostRef = gImportFS_gHost_Ref[importFSRef]
        exportFSRef = gImportFS_gExportFS_Ref[importFSRef]
        serverHostRef = gExportFS_gHost_Ref[exportFSRef]
    
        def createImportFS():
        
            Configurator.testHostConnections[hostConnRef] = None
            Configurator.talkToHost(hostConnRef, clientHostRef, \
                f"echo {gPassword[0]} | sudo -S mkdir -p /nfsTest/{gImportFS_Name[importFSRef]}")
                
            # Mount the !exported FS! as the !imported FS!
            Configurator.talkToHost(hostConnRef, clientHostRef, \
                f"echo {gPassword[0]} | sudo -S mount -o actimeo=5 {gHost_IP[gExportFS_gHost_Ref[exportFSRef]]}:/var/nfsTest/{gExportFS_Name[exportFSRef]} /nfsTest/{gImportFS_Name[importFSRef]}")

            Configurator.talkToHost(hostConnRef, clientHostRef, \
                f"echo {gPassword[0]} | sudo -S ./appendALine /etc/fstab '{gHost_IP[gExportFS_gHost_Ref[exportFSRef]]}:/var/nfsTest/{gExportFS_Name[exportFSRef]}  /nfsTest/{gImportFS_Name[importFSRef]}  nfs auto,nofail,noatime,nolock,intr,tcp,actimeo=5 0 0'")

            return
    
        def destroyImportFS():
        
            # Un-mount the !imported! FS
            Configurator.testHostConnections[hostConnRef] = None
            Configurator.talkToHost(hostConnRef, clientHostRef, \
                f"echo {gPassword[0]} | sudo -S umount /nfsTest/{gImportFS_Name[importFSRef]}")

            Configurator.talkToHost(hostConnRef, clientHostRef, \
                f"echo {gPassword[0]} | sudo -S ./removeALine /etc/fstab '{gHost_IP[gExportFS_gHost_Ref[exportFSRef]]}:/var/nfsTest/{gExportFS_Name[exportFSRef]}  /nfsTest/{gImportFS_Name[importFSRef]}'")

            Configurator.talkToHost(hostConnRef, clientHostRef, \
                f"echo {gPassword[0]} | sudo -S rm -rf /nfsTest/{gImportFS_Name[importFSRef]}")
                
            return
    
        # ImportFS actions
        while not gAllStop[0]:
        
            MasterLock.lock()
            
            # If this import FS belongs to a host that's a client type at this time
            if gHost_Role[clientHostRef] == "Client":

                # "Host-led deactivation" (deactivate started by someone "Deactivating" either the
                # client or server host...) and import is active and not used destroy the import
                if ((gHost_State[clientHostRef] == "Deactivating") or \
                    (gHost_State[serverHostRef] == "Deactivating")) and \
                   (gImportFS_State[importFSRef] == "Active") and \
                   (gImportFS_FSUserUseCount[importFSRef] == 0):
                   
                    # Unmount an imported FS
                    logging.info(f"Directed deactivate Import FS #{importFSRef}; name = {gImportFS_Name[importFSRef]}; state = {gImportFS_State[importFSRef]}")
                    
                    destroyImportFS()
                    
                    # Track activity of host, export and import FS
                    gExportFS_ImportFSUseCount[exportFSRef] -= 1
                    gHost_ImportFSUseCount[clientHostRef] -= 1
                    gImportFS_State[importFSRef] = "Inactive"
                
                # If activating an import FS and the export is active create the import
                elif (gImportFS_State[importFSRef] == "Activating") and \
                     (gExportFS_State[exportFSRef] == "Active"):
               
                    # Mount an export FS
                    logging.info(f"Activate Import FS #{importFSRef}; name = {gImportFS_Name[importFSRef]}; state = {gImportFS_State[importFSRef]}")
                    
                    createImportFS()

                    # Track activity of host and exported FS
                    gExportFS_ImportFSUseCount[exportFSRef] += 1
                    gHost_ImportFSUseCount[clientHostRef] += 1
                    gImportFS_State[importFSRef] = "Active"
                
                # If managing an active imported FS; do nothing
                elif gImportFS_State[importFSRef] == "Active":
               
                    # Do nothing
                    pass
                
                # If deactivating an unused import FS destroy the import FS
                elif (gImportFS_State[importFSRef] == "Deactivating") and \
                     (gImportFS_FSUserUseCount[importFSRef] == 0):
               
                    # Unmount an imported FS
                    logging.info(f"Undirected deactivate Import FS #{importFSRef}; name = {gImportFS_Name[importFSRef]}; state = {gImportFS_State[importFSRef]}")
                    
                    destroyImportFS()
                    
                    # Track activity of host and exported FS
                    gExportFS_ImportFSUseCount[exportFSRef] -= 1
                    gHost_ImportFSUseCount[clientHostRef] -= 1
                    gImportFS_State[importFSRef] = "Inactive"
                
                # If managing an unused imported FS; do nothing
                elif gImportFS_State[importFSRef] == "Inactive":
               
                    # Do nothing
                    pass
                
            # Unlock to wait in loop
            MasterLock.unlock()
    
            time.sleep(random.randrange(Configurator.secondsPerStateTransition))
            
        time.sleep(100000)

    # Implement file system user state machine
    def manageFSUserSM(fsUserRef, hostConnRef):
    
        # Get refs of who we are using from the import FS (we are running on the importing host)
        importFSRef = gFSUser_gImportFS_Ref[fsUserRef]
        exportFSRef = gImportFS_gExportFS_Ref[importFSRef]
        clientHostRef = gImportFS_gHost_Ref[importFSRef]    # The host we are running on
        serverHostRef = gExportFS_gHost_Ref[exportFSRef]    # The host our exported FS is running on
        
        #
        # From ioEngine comments:
        #
        # returnCode = 0           !          # Perfect result in w/r logic (+)
        # returnCode = 1           !          # Perfect verify of existing file (+)
        # returnCode = 14          --14       # Bad pass number after fixing it once (X)
        # returnCode = 15          !          # File too large (X)
        # returnCode = 16          !          # Data compare error in w/r logic (X)
        # returnCode = 17          !          # Data compare error in verification logic (X)
        # returnCode = 18          --18       # Clean premature EOF (+)
        # returnCode = 19          --19       # Fixed pass number once -  clean (+)
        # returnCode = 20          !          # Missing file (+)
        # returnCode = 21          !          # Empty file (+)
        # returnCode = 22          !          # Bad file start (X)

        #
        # X = Stop after failure
        # + = Count in platform UI
        # ! = Verify by hand
        # --nn = Generate bad file
        #
        # Do I/O on an active file system
        # 
        # Enter and leave locked but unlock for the actual I/O
        #
        def doIO():

            # Get directory name so we can pull parts of ioEngine file name out
            destPath = f"/nfsTest/{gImportFS_Name[importFSRef]}/"
            
            # Get a local copy of the file number and bump the number
            fileNum = gIOEngineNumber[0]            
            gIOEngineNumber[0] += 1

             # Force exactly one data compare error if set
            ff = ""
            if gHost_ForceDataCompareError[clientHostRef]:
                ff = "--ff"
                gHost_ForceDataCompareError[clientHostRef] = False
            
            # Do a write/read I/O with no lock
            MasterLock.unlock()
            
            logging.info(f"Use FS user #{fsUserRef}; name = {gFSUser_Name[fsUserRef]}; state = {gFSUser_State[fsUserRef]}")
            
            Configurator.testHostConnections[hostConnRef] = None
            (o, e, r) = Configurator.talkToHost(hostConnRef, clientHostRef, \
                f"echo {gPassword[0]} | sudo -S ./ioEngine --mp=10 {ff} {destPath}/{fileNum}", \
                stopOnError = False)
            
            MasterLock.lock()
            
            # Handle the possible returns frfom the main write/read ioEngine run            
            # A perfectly normal ioEngine write / read pass return code
            if r == 0:
                verifyDataFile = False
                gHost_OKWRCount[clientHostRef] += 1

            # Stop on data compare error
            elif r == 16:
                print ("")
                print ("Stopping after data compare error in ioEngine write / read logic. See nfsTest.log.")
                print ("")
                gAllStop[0] = True
                time.sleep(100000)

            # A Paramiko "connection loss" error
            elif r == -1:
                verifyDataFile = True
                gHost_BadConnCount[clientHostRef] += 1
                
                # Wait for the host to come back on line
                MasterLock.unlock()
                
                Configurator.testHostConnections[hostConnRef] = None
                (o, e, r) = Configurator.talkToHost(hostConnRef, clientHostRef, \
                    f"echo {gPassword[0]} | sudo -S date")
                
                MasterLock.lock()
                
            # Stop on unknown write / read error code
            else:
                print ("")
                print ("Stopping after unknown return code from ioEngine write / read logic. See nfsTest.log.")
                print ("")
                print (f"{gHost_Name[clientHostRef]}: retcode = {r}")
                print ("")
                gAllStop[0] = True
                time.sleep(100000)

            # If we need to verify any existing file on the mounted file system
            if verifyDataFile:
            
                MasterLock.unlock()
                
                Configurator.testHostConnections[hostConnRef] = None
                (o, e, r) = Configurator.talkToHost(hostConnRef, clientHostRef, \
                    f"echo {gPassword[0]} | sudo -S ./ioEngine --vf {destPath}/{fileNum}", \
                    stopOnError = False)
                
                MasterLock.lock()
                
                # Clean verify
                if r == 1:
                    gHost_OKVerifyCount[clientHostRef] += 1
                    
                # "Short" file
                elif r == 18:
                    gHost_PrematureEOFCount[clientHostRef] += 1
                    
                # Empty file
                elif r == 20:
                    gHost_MissingFileCount[clientHostRef] += 1
                    
                elif r == 21:
                    gHost_EmptyFileCount[clientHostRef] += 1
                    
                else:
                    print ("")
                    print ("Stopping after unknown return from ioEngine --vf operation. See nfsTest.log.")
                    print ("")
                    print (f"{gHost_Name[clientHostRef]}: retcode = {r}")
                    print ("")
                    gAllStop[0] = True
                    time.sleep(100000)

            return
        
        # FSUser actions
        while not gAllStop[0]:
        
            MasterLock.lock()

            # If this FS user belongs to a host that's a client type at this time
            if gHost_Role[clientHostRef] == "Client":

                # Host-led deactivation of a client or server host!!
                # If deactivating the client host or server host and the FS user is active, stop the FS user
                if ((gHost_State[clientHostRef] == "Deactivating") or \
                    (gHost_State[serverHostRef] == "Deactivating")) and \
                   (gFSUser_State[fsUserRef] == "Active"):
                   
                    # Start no more file system user threads
                    logging.info(f"Deactivate FS user #{fsUserRef}; name = {gFSUser_Name[fsUserRef]}; state = {gFSUser_State[fsUserRef]}")
                    
                    # Track activity
                    gHost_FSUserUseCount[clientHostRef] -= 1
                    gImportFS_FSUserUseCount[importFSRef] -= 1
                    gFSUser_State[fsUserRef] = "Inactive"

                # If creating an FS user and the import is active go to Active
                elif (gFSUser_State[fsUserRef] == "Activating") and \
                   (gImportFS_State[importFSRef] == "Active"):

                    # Start a file system user thread
                    logging.info(f"Activate FS user #{fsUserRef}; name = {gFSUser_Name[fsUserRef]}; state = {gFSUser_State[fsUserRef]}")
                    
                    # Track activity
                    gHost_FSUserUseCount[clientHostRef] += 1
                    gImportFS_FSUserUseCount[importFSRef] += 1
                    gFSUser_State[fsUserRef] = "Active"
                
                # If managing an active FS user start I/O and wait for it to finish
                elif gFSUser_State[fsUserRef] == "Active":
               
                    # This unlocks (only) during the actial I/O (write/read) and verification operations
                    doIO()
                
                # If destroying an FS user
                elif (gFSUser_State[fsUserRef] == "Deactivating"):
               
                    # Do nothing else here; import FS will unmount when use count goes to zero
                    logging.info(f"Deactivate FS user #{fsUserRef}; name = {gFSUser_Name[fsUserRef]}; state = {gFSUser_State[fsUserRef]}")
                    
                    # Track activity
                    gHost_FSUserUseCount[clientHostRef] -= 1
                    gImportFS_FSUserUseCount[importFSRef] -= 1
                    gFSUser_State[fsUserRef] = "Inactive"

                # If managing an unused FS user; do nothing
                elif gFSUser_State[fsUserRef] == "Inactive":
               
                    # Do nothing
                    pass
                
            # Unlock to wait in loop
            MasterLock.unlock()
    
            time.sleep(random.randrange(Configurator.secondsPerStateTransition))
            
        time.sleep(100000)

#
# Mainline code
#
if __name__ == "__main__":

    # Load in this program's code for in-line text processing
    InLineText.getCodeLines()

    # Handle help right away
    if (len(sys.argv) > 1) and (sys.argv[1] == "--help"):
        print (InLineText.getText("Help"))
        sys.exit(0)

    logging.basicConfig(filename = 'nfsTest.log', filemode = "a", \
            format = '%(asctime)s %(processName)s %(threadName)s %(funcName)s %(lineno)d %(message)s', \
            encoding = 'utf-8', level = logging.INFO)

    logging.info("")
    logging.info("")
    logging.info("Start nfsTest")

    # Set the start time
    gStartTime[0] = time.time()
    
    # Create or process the nfsTest.conf file (this will only return if it already exists)
    # Note - any test host definitions create rows in gHost!!
    Platform.processConfFile()
    
    # Connect to localhost to start with using the dedicated control host connection variable
    print ("")
    HostComm.controlHostConnection = paramiko.client.SSHClient()
    HostComm.controlHostConnection.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    HostComm.controlHostConnection.connect("localhost", username = gUsername[0], password = gPassword[0])
    
    # Verify pingability from the localhost / control host to the test hosts
    print ("")    
    for hostRef in range(len(gHost_RowStatus)):
        print (f"Ping from 'localhost' to {gHost_Identifier[hostRef]}")
        HostComm.executeOnLocalhostWithCheck(f"ping {gHost_Identifier[hostRef]} -c 1")

    # Now connect to all the test hosts with Paramiko
    print ("")
    for hostRef in range(len(gHost_RowStatus)):
        HostComm.addATestHostConnection(hostRef)

    time.sleep(3)
    
    # Present the menu and process user input - never return
    UI.coreInteractiveLogic()
        

""" - Help

Underway...

"""

"""

This is "Case Study 3" cited by the https://TestingComplexSystems.com web site.
   
This code sets up and randomly activates / deactivates a set of hosts running NFS 
workloads. While that is happening any random host can be stressed: rebooted or have its 
"role" (client or server) swapped.

If a server host is rebooted no client workloads should notice. If a client host is 
rebooted the workload on that client should cease operation and have to be accounted for 
approprietely when it starts to run again after recovery.


Program operation
=================

The goal here is to test a system as it grows and shrinks. Rather than create and delete 
table rows and stop and start threads while the test is under way we build a system that 
has enough hosts, a data store that has enough rows and a test platform with enough 
running threads to stand up the biggest system desired. We manage the rows / threads with 
a cooperating set of state machines.

{xxx} = See the nfsTest.conf file for the given variable names and values.

Execution starts by discovering the test hosts per {testhostIdentifier} rows in 
nfsTest.conf. Each test host gets a gHost row and initial NFS roles {serverCount} / 
{clientCount} are assigned.

The "ss" command creates gExportFS, gImportFS and gFSUser rows and it then creates a 
thread against each row to "execute" the state machine. The {exportFSPerHost} and 
{fsUserPerImportFS} (plus all exported file systems are imported on all clients) give the 
running system its maximum "size and shape".

While the FSUser resource is running the ioEngine utility is run against its assigned 
imported FS. If it gets an I/O error or a data compare error it will stop the platform.

The SMs are started in Inactive state at the UI. When directed they are (all) moved to 
Activating state (aa) from the UI and the platform "comes alive". After that a number of 
actions are available at the UI.


Use counts
==========

Besides states, the state machines rely on use counts to deceide on what to do when.

Use counts (ExportFS, ImportFS, FSUser) exist in 3 of the 4 tables (gHost, gFSExport, 
gImportFS). Each use count profiles how much the resource is being used by the "next" 
resource plus, the use counts in the gHost table indicate how much the host is being 
used by all the given resource in total.

(Note what use counts exist in nfsTest.dd...)

Make sure all counts are managed correctly: If more than one make sure to change both 
at the same time and check the index variable is "correct".


Host communication
==================

Paramiko connections are not thread safe. At startup and "setup" time the main thread 
uses class HostComm to work with the control host (HostComm.controlHostConnection) and 
test hosts (HostComm.testHostConnections[]) to clean and install software. No extra 
threads are used.

When a test is started each thread that's spawned generates it's own Paramiko connection 
object to the hosts it needs to work with (Configurator.testHostConnections[xxx] and 
Configurator.talkToHost). If Configurator.testHostConnections[xxx] is None the test host 
connection is renewed.

NOTE: NONE of the above variables are "gDS" variables.

Also, ssh has a limit of 10 connection attempts per second. We handle this by only 
connecting to a host when we need to.


ioEngine
========

This does I/O on the mounted file system and looks for I/O or data compare errors. See 
it for more details.

"""