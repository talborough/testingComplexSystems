#!/usr/bin/python3

# Remove exp
# Manage host if server / client

#
# nfsTest - An interactive "test platform" to run / test "NFS" on a number of Linux hosts.
#
# This creates / uses nfsTest.conf; The file is generated automatically if needed and it has
# more documentation in it. Its template is in the code below (class Platform).
#
# There is help text at the bottom of this file for the user *or* (./nfsTest --help)
#
# This consumea the gDS definition file nfsTest.py (you must first use gDSCodeGen on nfsTest.dd):
#
#       ../gDS/gDSCodeGen nfsTest             >>>>>> gDSCodeGen uses nfsTest.dd to produce nfsTest.py
#
# Note that the below is not an OO implementation.
#

from multiprocessing import Process
import threading
from threading import Thread
from multiprocessing import Lock

import paramiko
import logging

import time
import sys
import os
import select
import random
import getopt


#
# Consume the gDS include file generated by gDSCodeGen if it exists and it's not out of date
#
if (not os.path.exists("./nfsTest.py")) or \
   (os.path.getmtime("./nfsTest.dd") > os.path.getmtime("./nfsTest.py")):
    print ("")
    print ("./nfsTest.py does not exist or needs to be re-created with gDSCodeGen. Exiting.")
    print ("")
    sys.exit(1)
    
exec (open('nfsTest.py').read())


#
# Help control concurrent access to table rows.
#
class MasterLock:

    lockObject = Lock()

    def lock():
        
        MasterLock.lockObject.acquire()
        return
        
    def unlock():
    
        MasterLock.lockObject.release()
        return


#
# This support in-line text blocks and extractsing them at run time.
# It's good for templates and "help" blocks.
#
class InLineText:

    codeLines = []

    def getCodeLines():
    
        InLineText.codeLines = open(sys.argv[0], "r").read().splitlines()


    def getText(tag, substitutionList = []):

        lineRef = 0
        harvestingText = False
        harvestedText = ''

        while lineRef <= len(InLineText.codeLines):

            line = InLineText.codeLines[lineRef]
            lineRef += 1

            if (not harvestingText) and ('""" - ' in line):
                indent = line.find('"""')
                line = line[indent:]
                line = line.replace('""" - ', "")
                if line == tag:
                    harvestingText = True
                    
            elif (not harvestingText) and (lineRef == len(InLineText.codeLines)):
                print ("Can not find in-line text tag '%s'" % (tag))
                x = 1/0

            elif harvestingText and ('"""' in line):
                return (harvestedText % (substitutionList))
                
            elif harvestingText:
                harvestedText += line[indent:] + "\n"


#
# Screen color codes
# 
class Color:

    RED = "\u001b[31m"
    GREEN = "\u001b[32m"
    YELLOW = "\u001b[33m"
    BLUE = "\u001b[34m"
    MAGENTA = "\u001b[35m"
    CYAN = "\u001b[36m"
    WHITE = "\u001b[37m"


#
# Support inter-host communication for the main thread of the nfsTest code.
#
# This code supports communication between the Control Host and the Test Hosts using Paramiko 
# (using ssh).
#
# Note that the code in the state machines that performs NFS-related command-line activity (make 
# directories; mount file systems) uses per-thread connection onjects created in that code (Paramiko isn't 
# thread safe so the simplest bet is to create thread-local connection objects as they are needed
# in that code.)
#
class HostComm:

    # This list of Paramiko connections parallels gDS table gHost. Element [0] is the localhost.
    hostConnections = []

    # Set up HostComm.hostConnections[hostRef] instances for the hostRef list passed in
    def connectToHostRefList(hostRefList):

        HostComm.hostConnections = []
        
        print ("")
        
        for hostRef in hostRefList:
        
            try:

                HostComm.hostConnections.append(paramiko.client.SSHClient())
                HostComm.hostConnections[hostRef].set_missing_host_key_policy(paramiko.AutoAddPolicy())
                HostComm.hostConnections[hostRef].connect(gHost_Identifier[hostRef], username = gUsername[0], password = gPassword[0])
                
                # Get the IP and hostname of the host and set them in the gDS gHost table
                (i, o, e) = HostComm.executeOnOneHost(hostRef, "hostname -I")
                gHost_IP[hostRef] = o.read().decode().strip()
                (i, o, e) = HostComm.executeOnOneHost(hostRef, "hostname")
                gHost_Hostname[hostRef] = o.read().decode().strip()
                
                gHost_Name[hostRef] = f"host #{hostRef}"
                
                print (f"Create a paramiko ssh connection to {gHost_Name[hostRef]} / {gHost_Identifier[hostRef]} / {gHost_IP[hostRef]} / {gHost_Hostname[hostRef]}")

            except Exception as e:
            
                print (e)
                logging.info(f"{e}")
                print ("Check that the ssh server is installed and running (see nfsTest.conf file for directions)")
                sys.exit(1)
                
        return
        
    # Reconnect to an existing connection
    def reconnectToHostRefList(hostRefList):

        for hostRef in hostRefList:
        
            print (f"Reconnect to {gHost_Name[hostRef]}")
        
            try:

                HostComm.hostConnections[hostRef] = paramiko.client.SSHClient()
                HostComm.hostConnections[hostRef].set_missing_host_key_policy(paramiko.AutoAddPolicy())
                HostComm.hostConnections[hostRef].connect(gHost_Identifier[hostRef], username = gUsername[0], password = gPassword[0])

            except Exception as e:
            
                print (e)
                sys.exit(99)
                
    def putFile (hostRef, src, dest):
 
        ftp_client = HostComm.hostConnections[hostRef].open_sftp()
        ftp_client.put(src, dest)
        ftp_client.close()
        
        return

    def getFile (hostRef, src, dest):
 
        ftp_client = HostComm.hostConnections[hostRef].open_sftp()
        ftp_client.get(src, dest)
        ftp_client.close()
        
        return

    # Execute a command on a host and return result of "(i, o, e)"
    def executeOnOneHost(hostRef, command):
    
        return HostComm.hostConnections[hostRef].exec_command(command)

    # Execute a command on a host with a wait and return result of "(i, o, e)"
    def executeOnOneHostWithWait(hostRef, command):
    
        time.sleep(0.2)
    
        return HostComm.hostConnections[hostRef].exec_command(command)

    # Execute a command on a host and return result of "(i, o, e)"
    def executeOnOneHostWithCheck(hostRef, command):
    
        (i, o, e) = HostComm.hostConnections[hostRef].exec_command(command)

        retcode = o.channel.recv_exit_status()
        
        if retcode:
        
            print ("")
            print (f"retcode = {retcode}")
            print ("")
            print (f"Host = #{hostRef}")
            print ("")
            print (f"Command = {command}")
            print ("")
            print (o.read().decode())
            print ("")
            print (f"stderr = {e.read().decode()}")
            print ("")
            print (f"retcode = {retcode}")
            print ("")
            print (f"Output above from {gHost_Name[hostRef]} / {gHost_Identifier[hostRef]} / {gHost_IP[hostRef]} / {gHost_Hostname[hostRef]}")
            print ("")
            
            sys.exit(1)
            
        return (i, o, e)
        

    # Get a list hosts to operate on from user input
    def getHostRefList(prompt, processControlHost):
    
        startRange = 1
        if processControlHost:
            startRange = 0
    
        print ("")
        for hostRef in range(startRange, len(gHost_RowStatus)):
        
            print ("%d) - %20s %20s %20s" % (hostRef, gHost_Identifier[hostRef], gHost_IP[hostRef], gHost_Hostname[hostRef]))
            
        print ("")
        if processControlHost:
            print ("'all' = all; 'test' = all but '0'; or, numbers separated by whitespace")
        else:
            print ("'test' = all but '0'; or, numbers separated by whitespace")
        print ("")
        
        selection = input(prompt)
        
        retValueList = []
        if "all" in selection:
            retValueList = range(0, len(gHost_RowStatus))
        elif "test" in selection:
            retValueList = range(1, len(gHost_RowStatus))
        else:
            selection = selection.split()
            for string in selection:
                retValueList.append(int(string))
                
        if (not processControlHost) and (0 in retValueList):
        
            print ("")
            print ("This operation can not be performed on the Control Host (#0)")
            print ("")
            input("Hit Enter to continue: ")
            retValueList = []
            
        return (retValueList)


#
# General-purpose test platform-related activities
#
class Platform:

    #
    # The nfsTest.conf file template
    #
    
    """ - nfsTest.conf
    #
    # nfsTest.conf - Define what's needed to get the nfsTest "test platform" up and running.
    #
    
    # Hint: When creating the necessary VMs put consecutive numbers at the end of the VM names in 
    # the hypervisor so the VM data files can be identified and deleted by hand if 
    # necessary (some hypervisors don't automatically delete VM data files when deleting the VM). 
    # Use the same number when specifying the 'hostname' so it shows up in the command line.

    # Next, when creating and setting up each of the control and test hosts, use the same privileged
    # username / password pair for all the systems. Doing it this way doesn't require ssh keys.
    
    # Finally, the ssh server package must be installed (by hand) on the control host and each of the test 
    # hosts systems defined below. After that we will be able to do everything else with nfsTest. To do the ssh 
    # install on each host:
    #
    #   sudo apt update                                 # Update the install libraries
    #   sudo apt install openssh-server                 # Install and start the ssh server
    #
    #   sudo systemctl status ssh                       # Show the status of the ssh server if necessary
    #
    # Provide (below) the username and password for all activities to use on the control host and test hosts.
    #
    
    username = <username with the sudo priv to be used accessing *all* host systems>
    password = <password to go with the above username>
    
    # Provide the server and client counts
    
    serverCount = 1
    clientCount = 2
    
    # Provide the IP address or resolvable DNS name of the test hosts:
    
    testhostIdentifier = <resolvable host name or ip #1>
    testhostIdentifier = <resolvable host name or ip #2>
    testhostIdentifier = <resolvable host name or ip #3>
    
    # These control the size and shape of the configuration being tested.

    exportFSPerHost = 3
    fsUserPerImportFS = 3

    # This adjusts the rate at which the 'activator' forces state machine ransitions
    
    secondsPerStateTransition = 1
    transitionsPerHost = 1
    transitionsPerExportFS = 3
    transitionsPerImportFS = 10
    transitionsPerFSUser = 30
    
    """

    #
    # Get the ball rolling by creating or processing the nfsTest.conf file
    #
    def processConfFile():
    
        # Save here until we set up all gHosts below in this method
        serverCount = None
        clientCount = None
    
        # Create conf file if there is none then exit
        if not os.path.exists("nfsTest.conf"):
        
            fileDesc = open("nfsTest.conf", "w")
            fileDesc.write(InLineText.getText("nfsTest.conf"))
            fileDesc.close()
            print ("")
            print ("********************************************************")
            print ("We have just written the 'nfsTest.conf' file in the default directory")
            print ("where you can read and edit it.")
            print ("********************************************************")
            print ("")
            sys.exit(0)
        
        # Conf file is here so let's process it
        
        # Make the control host (localhost) hostRef 0
        # Add the production row
        logging.info("Add Control gHost row")
        gHost_AddARow(_Identifier = "localhost", _IP = "localhost", _Role = "Control", _State = "")
                
        confLines = open("nfsTest.conf", "r").read().splitlines()
        
        lineIndex = 0

        while lineIndex < len(confLines):
        
            # Get next line
            line = confLines[lineIndex]
        
            # Split off any comment
            if "#" in line:
                (line, dummy) = line.split("#", 1)
                
            # If something left it's hopefully "key = value"
            if line != "":
                
                # Split what's left by whitespace
                lineBits = line.split()
                
                if (len(lineBits) != 3) or (lineBits[1] != "="):
                    print ("")
                    print (f"Bad line in nfsTest.conf file at line {lineIndex + 1}")
                    print ("")
                    print (f"Line = {confLines[lineIndex]}")
                    print ("")
                    sys.exit(1)
                    
                # Set common username
                if lineBits[0] == "username":
                    gUsername[0] = lineBits[2]
                
                # Set common password
                elif lineBits[0] == "password":
                    gPassword[0] = lineBits[2]
                
                # Add another host to the list
                elif lineBits[0] == "testhostIdentifier":
                
                    # If we still need hosts
                    if len(gHost_RowStatus) < (serverCount + clientCount + 1):
                
                        # Add a production row; roles are set below after parsing all of the nfsTest.conf file
                        gHost_AddARow(_Identifier = lineBits[2])
                        logging.info(f"Adding a gHost row for {lineBits[2]}")
                        
                    else:
                    
                        print ("")
                        print (f"Ignoring extra 'testhostIdentifier' {lineBits[2]}")

                elif lineBits[0] == "serverCount":
                    serverCount = int(lineBits[2])
                    
                elif lineBits[0] == "clientCount":
                    clientCount = int(lineBits[2])

                elif lineBits[0] == "exportFSPerHost":
                    Configurator.exportFSPerHost = int(lineBits[2])

                elif lineBits[0] == "fsUserPerImportFS":
                    Configurator.fsUserPerImportFS = int(lineBits[2])
                    
                elif lineBits[0] == "secondsPerStateTransition":
                    Configurator.secondsPerStateTransition = int(lineBits[2])
                    
                elif lineBits[0] == "transitionsPerHost":
                    Configurator.transitionsPerHost = int(lineBits[2])
                    
                elif lineBits[0] == "transitionsPerExportFS":
                    Configurator.transitionsPerExportFS = int(lineBits[2])
                    
                elif lineBits[0] == "transitionsPerImportFS":
                    Configurator.transitionsPerImportFS = int(lineBits[2])
                    
                elif lineBits[0] == "transitionsPerFSUser":
                    Configurator.transitionsPerFSUser = int(lineBits[2])
                    
                else:
                
                    print ("")
                    print (f"Unknown keyword {lineBits[0]} in nfsTest.conf at line {lineIndex + 1}. Exiting.")
                    print ("")
                    sys.exit(1)                    
                    
            # Bump line pointer
            lineIndex += 1
            
        # The contrl gHost row has been made above; set server and client roles
        
        # Make sure we have enough hosts to satisfy the server and client counts in the nfsTest.conf file
        if (serverCount + clientCount + 1) > len(gHost_RowStatus):
            print ("")
            print (" The nfsTest.conf file doesn't specify enough hosts to fit the server and client counts also specified in it.")
            print (" Exiting.")
            print ("")
            sys.exit(1)
        
        hostRef = 1
        for i in range(serverCount):
            gHost_Role[hostRef] = "Server"
            gHost_State[hostRef] = "Inactive"
            hostRef += 1

        for i in range(clientCount):
            gHost_Role[hostRef] = "Client"
            gHost_State[hostRef] = "Inactive"
            hostRef += 1

        return

    # Ping out to all from localhost
    def pingAllFromLocalhost():
    
        print ("")
        
        for hostRef in range(0, len(gHost_RowStatus)):

            print (f"Ping from 'localhost' to {gHost_Identifier[hostRef]}")
            (i, o, e) = HostComm.executeOnOneHostWithCheck(hostRef = 0, command = f"ping {gHost_Identifier[hostRef]} -c 1")
            
        return

    #
    # Put the necessary software on any host.
    #
    # !! Reload NFS server !!
    """ - Package installs
    
    sudo -S apt -y update
    sudo -S apt -y install python3-pip
    sudo -S pip3 install numpy
    sudo -S apt -y install sshpass
    sudo -S apt -y install nfs-kernel-server
    sudo -S systemctl restart nfs-kernel-server
    sudo -S systemctl status ssh
    
    """

    """ - File copies
    
    appendALine
    removeALine
    ioEngine
    
    """
    
    #
    # Load necessary packages and copy necessary files onto the test host(s)
    #
    def loadSWOnTestHosts():
    
        # Get the lists above
        packageLoadList = InLineText.getText("Package installs").splitlines()
        fileCopyList = InLineText.getText("File copies").splitlines()
        
        hostRefList = HostComm.getHostRefList("Enter test hosts to load the necessary pagkages and files: ", processControlHost = False)
            
        if len(hostRefList):

            print ("")
            
            for hostRef in hostRefList:

                for command in packageLoadList:
                
                    if command:
                
                        command = f"echo {gPassword[0]} | {command}"
                    
                        print (f"Execute '{command}' on test {gHost_Name[hostRef]}")
                        (i, o, e) = HostComm.executeOnOneHostWithCheck(hostRef, command)

                print ("")
            
                # Do file copies
                for file in fileCopyList:
                
                    if file:
                
                        print (f"Copy ./{file} to test {gHost_Name[hostRef]} and make it executable")
                        HostComm.putFile(hostRef, f"./{file}", f"./{file}")
                        (i, o, e) = HostComm.executeOnOneHostWithCheck(hostRef, f"chmod 0755 ./{file}")
                            
                print ("")

        print ("")
        input ("Hit Enter to continue: ")

        return


#
# The UI class houses code that gives the UI its look and feel, that starts a run "on its way", that
# monitors the run's progress, and that services interactive and batch operation.
#
class UI:

    # Help the user remember where they are
    lastCommand = "<none>"

    # The currently displaying screen (we only have one)
    displayName = "configuratorStates"
    
    # Process user input
    def processCommand(command):
    
        # Help
        if command == "help":
        
            print (InLineText.getText("Help"))
            input ("Enter <CR> to continue: ")
            
            
        elif command == "cleanall":
        
            def doIt():
        
                #
                # Stop and clean up *all* nfsTest-ing artifacts
                # Do not use any gDS entries
                # Use only artifacts found on the hosts
                # We can clean out the related gDS entries after if needed
                #
                # Kill any processes using the client mount points so the unmounts work
                for hostRef in range(1, len(gHost_RowStatus)):
                    (i, o, e) = HostComm.executeOnOneHostWithWait(hostRef, \
                            f"echo {gPassword[0]} | sudo -S lsof -N | grep 'nfsTest\|ioEngine'")
                    lsofLines = o.read().decode().splitlines()
                    # print (1, len(lsofLines))
                    for lsofLine in lsofLines:
                        # print (lsofLine)
                        process = lsofLine.split()[0]
                        pid = lsofLine.split()[1]
                        mntPoint = lsofLine.split()[-2]
                        print (f"Kill process '{process}' / '{pid}' using '{mntPoint}' on {gHost_Name[hostRef]}")
                        HostComm.executeOnOneHostWithWait(hostRef, \
                            f"echo {gPassword[0]} | sudo -S kill -9 {pid}")
                #
                # Unmount all nfsTest client shares on all hosts
                for hostRef in range(1, len(gHost_RowStatus)):
                    (i, o, e) = HostComm.executeOnOneHostWithWait(hostRef, "df")
                    dfLines = o.read().decode().splitlines()
                    for dfLine in dfLines:
                        if "nfsTest" in dfLine:
                            dfMountpoint = dfLine.split()[-1]
                            print (f"Unmount '{dfMountpoint}' on {gHost_Name[hostRef]}")
                            HostComm.executeOnOneHostWithWait(hostRef, \
                                f"echo {gPassword[0]} | sudo -S umount {dfMountpoint}")
                            time.sleep(1)
                    print (f"Clean out '/etc/fstab' on {gHost_Name[hostRef]}")
                    HostComm.executeOnOneHostWithWait(hostRef, \
                        f"echo {gPassword[0]} | sudo -S ./removeALine /etc/fstab nfsTest")
                    print (f"Delete '/var/nfsTest' on {gHost_Name[hostRef]}")
                    HostComm.executeOnOneHostWithWait(hostRef, \
                        f"echo {gPassword[0]} | sudo -S rm -rf /var/nfsTest")
                    print (f"Delete '/var/ioEngine' on {gHost_Name[hostRef]}")
                    HostComm.executeOnOneHostWithWait(hostRef, \
                        f"echo {gPassword[0]} | sudo -S rm -rf /var/ioEngine")

                # Un-export all nfsTest shares, restart the servers and delete the shared directories
                for hostRef in range(1, len(gHost_RowStatus)):
                    print (f"Clean '/etc/exports' file on {gHost_Name[hostRef]}")
                    HostComm.executeOnOneHostWithWait(hostRef, \
                        f"echo {gPassword[0]} | sudo -S ./removeALine /etc/exports nfsTest")
                    print (f"Restart NFS server on {gHost_Name[hostRef]}")
                    HostComm.executeOnOneHostWithWait(hostRef, \
                        f"echo {gPassword[0]} | sudo -S systemctl restart nfs-kernel-server")
                    print (f"Delete '/var/nfsTest' on {gHost_Name[hostRef]}")
                    HostComm.executeOnOneHostWithWait(hostRef, \
                        f"echo {gPassword[0]} | sudo -S rm -rf /var/nfsTest")
                    print (f"Delete '/nfsTest' on {gHost_Name[hostRef]}")
                    HostComm.executeOnOneHostWithWait(hostRef, \
                        f"echo {gPassword[0]} | sudo -S rm -rf /nfsTest")
                        
            print ("")
                        
            doIt()

            hostRefList = []
            
            # See if any directories with stale file handles exist and reboot
            for hostRef in range(1, len(gHost_RowStatus)):
                print (f"Checking for undeleted 'nfsTest' directories on {gHost_Name[hostRef]}")
                (i, o, e) = HostComm.executeOnOneHostWithWait(hostRef, \
                    f"echo {gPassword[0]} | sudo -S ls -al /nfsTest")
                output = o.read().decode()
                print (output)
                if "???" in output:
                    print (f"Rebooting {gHost_Name[hostRef]}")
                    HostComm.executeOnOneHostWithWait(hostRef, \
                        f"echo {gPassword[0]} | sudo -S shutdown -r now")

                    hostRefList.append(hostRef)
                        
            # Reconnect to an existing connection and clean what's leftover
            if len(hostRefList):
                print ("")
                print ("Wait 20 seconds for the Linux reboot(s)")
                print ("")
                time.sleep(20)
                HostComm.reconnectToHostRefList(hostRefList)
                print ("")

                doIt()
                
            print ("")
            input ("Hit Enter to continue: ")


        elif command == "put":
        
            HostComm.putFile(int(input("hostRef: ")), input("Src: "), input("Dest: "))


        elif command == "get":
        
            HostComm.getFile(int(input("hostRef: ")), input("Src: "), input("Dest: "))

            
        # Execute command(s) on user-selectable hosts
        elif command == "ecmd":
        
            hostRefList = [None, None]
            
            while len(hostRefList):
        
                hostRefList = HostComm.getHostRefList("Enter where to execute the command(s): ", processControlHost = True)
                
                if len(hostRefList):
                
                    command = "x"
                    
                    while command:

                        print ("")
                        print ("systemctl status ssh")
                        print ("")
                        command = input ("Enter the command to execute remotely: ")
                        command = command.strip()

                        if command:
                            for hostRef in hostRefList:
                                (i, o, e) = HostComm.executeOnOneHost(hostRef, command.strip())
                                print ("")
                                print ("retcode = ", o.channel.recv_exit_status())
                                print ("")
                                print (o.read().decode())
                                print ("")
                                print (f"stderr = {e.read().decode()}")
                                print ("")
                                print ("retcode = ", o.channel.recv_exit_status())
                                print ("")
                                print (f"Output from {gHost_Name[hostRef]} / {gHost_Identifier[hostRef]} / {gHost_IP[hostRef]} / {gHost_Hostname[hostRef]}")
                                print ("")


        # Install necessary software packages on selected hosts
        elif command == "insw":
        
            Platform.loadSWOnTestHosts()


        # Process "start a test run" command
        elif command == "st":

            gActivatorState[0] = "Activate randomly"

            Configurator.mainTestProcess = Process(target = Configurator.startATestRunProcess, \
                                                     name = "main test process", \
                                                     args = ())
            Configurator.mainTestProcess.start()


        elif command == "swap2":
        
            gActivatorState[0] = "Swap host #2's role"


        elif command == "reboot1":
            
            HostComm.executeOnOneHostWithWait(1, f"echo {gPassword[0]} | sudo -S shutdown -r now")
       
        
        elif command == "et":
        
            gActivatorState[0] = "Deactivate randomly"


        elif command == "exit":
        
            gActivatorState[0] = "Stop all activity"


        # Dump host table
        elif command == "dh":
            gHost_DumpTable()
            print ("")
            input (" Hit Enter to continue: ")

            
        # Dump FS export table
        elif command == "de":
            gExportFS_DumpTable()
            print ("")
            input (" Hit Enter to continue: ")

            
        # Dump FS import table
        elif command == "di":
            gImportFS_DumpTable()
            print ("")
            input (" Hit Enter to continue: ")

            
        # Dump FS user table
        elif command == "du":
            gFSUser_DumpTable()
            print ("")
            input (" Hit Enter to continue: ")

            
        else:
            UI.lastCommand = ""
            print ("")
            print (f"Invalid command: '{command}'")
            time.sleep(2)

        return


    # Service the updating of the terminal screen
    def serviceTerminal(getInput):
    
        displayLines = "\033[H\033[J \n"

        # Decide what display to show
        if UI.displayName == "configuratorStates":
        
            x = Color.RED
            y = Color.WHITE
            displayLines += " Uptime: %d secs; Activator state: %s%s%s \n" % ((time.time() - gStartTime[0]), x, gActivatorState[0], y)
            
            if (time.time() - gStartTime[0]) > 600:
                print (displayLines)
                print ("")
                print ("Stopping after 10 minutes so we don't consume a lot disk space in nfsTest.log.")
                print ("")
                exit (0)
            
            displayLines += " \n"
            displayLines += Configurator.generateStatisticsDisplay(displayLines)
            
            # Update menu
            displayLines += " \n"
            displayLines += " dh / de / di / du = Dump hosts / exportFS / importFS / FSUser tables \n"
            
            displayLines += " insw       = Install all necessary software packages on any host(s) \n"
            displayLines += " cleanall   = Clean up all artifacts on all test host(s) no matter what \n"
            displayLines += " ecmd       = Execute command(s) on any host(s) \n"
            displayLines += " st / et    = Start / end testing \n"
            displayLines += " swap2 / reboot1  = swap role on host #2 / reboot host #1 \n"
            displayLines += " \n"
                
            displayLines += " help     = Print help on the screen \n"
            displayLines += " \n"
            displayLines += f" Last command = '{UI.lastCommand}' \n"
    
            # Print whole screen with one command (no flashing)
            print (displayLines)

            i = ""
            if getInput:
                # Get any user input and also pause for 2 seconds
                print (" Type a command from the menu above then hit Enter:")
                i, o, e = select.select([sys.stdin], [], [], 2)
            else:
                time.sleep(2)
            
            # If some input
            if i:
            
                command = sys.stdin.readline().strip()
                
                UI.lastCommand = command

                # Process user input
                UI.processCommand(command)

        return (displayLines)
        

    # Watch/control what's going on from display rendered on terminal
    def coreInteractiveLogic():
    
        # Always update the screen - need a "exit" command to exit
        while UI.lastCommand != "exit":

            # Update screen and process any user input
            UI.serviceTerminal(getInput = True)

        # Must be "exit" command - wait for deactivation of all resources with no user input
        while gAllActive[0] != 0:

            # Update screen only
            UI.serviceTerminal(getInput = False)
            
        # Wait for the one main test process
        startWaitTime = time.time()
        while Configurator.mainTestProcess.is_alive():
            print (f"Waiting for main test process to stop ({int(time.time() - startWaitTime)})")
            time.sleep(3)
            
        # Join up to the above
        Configurator.mainTestProces.join()
        
        print ("")
        print ("Successfully exiting nfsTest main thread")
        sys.exit(0)


"""

Command "st" starts one "mainTestProcesses" in "startATestRunProcess"
    Define state machine rows in defineAllResourceControlRows in "startATestRunProcess"
    Start one "perHostResourceManagementProcesses" per host in "startATestRunProcess"
        Start one "resourceThreads" per resource row in "startAllConfiguratorThreads"
    Advance the state machine(s) in "activator"

"""


class Configurator:

    # Must be mindful of the process / thread contexts these are being used in
    mainTestProcess = None                      # Spawned from THE main thread (in startATestRunProcess)
    perHostResourceManagementProcesses = []     # Spawned from the above process (in startAConfiguratorProcessesPerHost)
    resourceThreads = []                        # Spawned from the above processes (in startAllConfiguratorThreads)

    # These are set by entries in the nfsTest.conf file. They control the size and shape
    # of the configuration being tested and the rate at which it operates
    exportFSPerHost = None
    fsUserPerImportFS = None

    # The below control how the activator works and also come from the nfsTest.conf file
    secondsPerStateTransition = None
    transitionsPerHost = None
    transitionsPerExportFS = None
    transitionsPerImportFS = None
    transitionsPerFSUser = None
    
    def talkToHost(hostConnection, hostRef, command):
    
        logging.info(f"Execute on {gHost_Name[hostRef]}; {command}")

        (i, o, e) = hostConnection.exec_command(command)

        retcode = o.channel.recv_exit_status()
        
        if retcode:
        
            logging.info(f"Execute on {gHost_Name[hostRef]}; {command} failed !!!!!!!!!!!!!!!!!!!!")
            logging.info(f"Execute on {gHost_Name[hostRef]}; {command} failed !!!!!!!!!!!!!!!!!!!!")
            logging.info(f"Execute on {gHost_Name[hostRef]}; {command} failed !!!!!!!!!!!!!!!!!!!!")

            logging.info("")
            logging.info(f"retcode = {retcode}")
            logging.info("")
            logging.info(f"Host = #{hostRef}")
            logging.info("")
            logging.info(f"Command = {command}")
            logging.info("")
            logging.info(o.read().decode())
            logging.info("")
            logging.info(f"stderr = {e.read().decode()}")
            logging.info("")
            logging.info(f"retcode = {retcode}")
            logging.info("")
            logging.info(f"Output above from {gHost_Name[hostRef]}")
            logging.info("")

            gActivatorState[0] = "Waiting for a command error to be investigated - see nfsTest.log"
            
            time.sleep(10000)
            
        return (o.read().decode())

    def calculateStatistics():
    
        startTime = time.time()

        gHostInactive[0] = gHost_State.count("Inactive")
        gHostActivating[0] = gHost_State.count("Activating")
        gHostActive[0] = gHost_State.count("Active")
        gHostDeactivating[0] = gHost_State.count("Deactivating")
    
        gExportFSInactive[0] = gExportFS_State.count("Inactive")
        gExportFSActivating[0] = gExportFS_State.count("Activating")
        gExportFSActive[0] = gExportFS_State.count("Active")
        gExportFSDeactivating[0] = gExportFS_State.count("Deactivating")
    
        gImportFSInactive[0] = gImportFS_State.count("Inactive")
        gImportFSActivating[0] = gImportFS_State.count("Activating")
        gImportFSActive[0] = gImportFS_State.count("Active")
        gImportFSDeactivating[0] = gImportFS_State.count("Deactivating")
    
        gFSUserInactive[0] = gFSUser_State.count("Inactive")
        gFSUserActivating[0] = gFSUser_State.count("Activating")
        gFSUserActive[0] = gFSUser_State.count("Active")
        gFSUserDeactivating[0] = gFSUser_State.count("Deactivating")
        
        gAllInactive[0] = gHostInactive[0] + gExportFSInactive[0] + gImportFSInactive[0] + gFSUserInactive[0]
        gAllActivating[0] = gHostActivating[0] + gExportFSActivating[0] + gImportFSActivating[0] + gFSUserActivating[0]
        gAllActive[0] = gHostActive[0] + gExportFSActive[0] + gImportFSActive[0] + gFSUserActive[0]
        gAllDeactivating[0] = gHostDeactivating[0] + gExportFSDeactivating[0] + gImportFSDeactivating[0] + gFSUserDeactivating[0]
        
        gConfigStatsDelta[0] = time.time() - startTime
        
        return
            
    def generateStatisticsDisplay(displayLines):

        Configurator.calculateStatistics()
    
        displayLines += "                    Host     exportFS     importFS       FSUser \n"
        displayLines += " Resource state    Count        Count        Count        Count \n"
        displayLines += " --------------    -----     --------     --------       ------ \n"
        displayLines += " Inactive           %4d         %4d         %4d         %4d \n" % (gHostInactive[0], gExportFSInactive[0], gImportFSInactive[0], gFSUserInactive[0])
        displayLines += " Activating         %4d         %4d         %4d         %4d \n" % (gHostActivating[0], gExportFSActivating[0], gImportFSActivating[0], gFSUserActivating[0])
        displayLines += " Active             %4d         %4d         %4d         %4d \n" % (gHostActive[0], gExportFSActive[0], gImportFSActive[0], gFSUserActive[0])
        displayLines += " Deactivating       %4d         %4d         %4d         %4d \n" % (gHostDeactivating[0], gExportFSDeactivating[0], gImportFSDeactivating[0], gFSUserDeactivating[0])
        #displayLines += " Disabling          %4d         %4d         %4d         %4d \n" % (gHostDisabling[0], gExportFSDisabling[0], gImportFSDisabling[0], gFSUserDisabling[0])
        #displayLines += " Disabled           %4d         %4d         %4d         %4d \n" % (gHostDisabled[0], gExportFSDisabled[0], gImportFSDisabled[0], gFSUserDisabled[0])
        displayLines += " \n"
        
        displayLines += " Host ID          Role          State    ExportFS   ImportFS   FSUser   IO Count\n"
        displayLines += " -------          ----          -----    --------   --------   ------   --------\n"
        
        for hostRef in range(len(gHost_RowStatus)):
            displayLines += "%8s      %8s   %12s        %4d       %4d     %4d       %4d \n" % (gHost_Name[hostRef], \
                                                                                         gHost_Role[hostRef], \
                                                                                         gHost_State[hostRef], \
                                                                                         gHost_ExportFSUseCount[hostRef], \
                                                                                         gHost_ImportFSUseCount[hostRef], \
                                                                                         gHost_FSUserUseCount[hostRef], \
                                                                                         gHost_IOCount[hostRef])
        displayLines += " \n"
        displayLines += f" Display generation time = {int(gConfigStatsDelta[0] * 1000)} ms; host ssh connections: {gConnectionsMadeCount[0]} made of {gConnectionsNeededCount[0]} \n"
        
        return (displayLines)
    
    def startATestRunProcess():
    
        # Define all gDS rows per resource
        Configurator.defineAllResourceControlRows()
        # Start a process per host row and they then each start a thread per resource row for that host
        Configurator.startAConfiguratorProcessesPerHost()
        # Start to activate resources
        Configurator.activator()
        # <End of thread>

    def defineAllResourceControlRows():
    
        # Make all possible export FS rows
        for hostRef in range(1, len(gHost_RowStatus)):
            for exportFSNum in range(Configurator.exportFSPerHost):
                exportFSRef = gExportFS_AddARow(_gHost_Ref = hostRef,
                                                _Name = f"host_{'%4.4x' %(hostRef)}_export_{'%4.4x' % (len(gExportFS_RowStatus))}")
                logging.info(f"Add export FS row for {gHost_Name[hostRef]}")
                                            
        # Make all possible import FS rows for the export FS rows
        for hostRef in range(1, len(gHost_RowStatus)):
            for exportFSRef in range(len(gExportFS_RowStatus)):
                # Do not make imports that match exports
                if hostRef != gExportFS_gHost_Ref[exportFSRef]:
                    importFSRef = gImportFS_AddARow(_gHost_Ref = hostRef,
                                                    _gExportFS_Ref = exportFSRef,
                                                    _Name = f"host_{'%4.4x' % (hostRef)}_export_{'%4.4x' % (exportFSRef)}_import_{'%4.4x' % (len(gImportFS_RowStatus))}")
                    logging.info(f"Add import FS row for {gHost_Name[hostRef]}, {gExportFS_Name[exportFSRef]}")
                
        # Make all possible FS User rows for the import FS rows
        for hostRef in range(1, len(gHost_RowStatus)):
            for importFSRef in range(len(gImportFS_RowStatus)):
                # Only make rows for FS users on the same host as the import
                if hostRef == gImportFS_gHost_Ref[importFSRef]:
                    for fsUserNum in range(Configurator.fsUserPerImportFS):
                        fsUserRef = gFSUser_AddARow(_gHost_Ref = hostRef,
                                                    _gExportFS_Ref = gImportFS_gExportFS_Ref[importFSRef],
                                                    _gImportFS_Ref = importFSRef,
                                                    _Name = f"host_{'%4.4x' % (gImportFS_gHost_Ref[importFSRef])}_export_{'%4.4x' % (gImportFS_gExportFS_Ref[importFSRef])}_import_{'%4.4x' % (importFSRef)}_user_{'%4.4x' % (len(gFSUser_RowStatus))}")
                        logging.info(f"Add FS user row for {gHost_Name[hostRef]}, {gImportFS_Name[importFSRef]}")

        return
    
    # Start one process per host; that process starts the 4 types of state management threads
    def startAConfiguratorProcessesPerHost():
    
        MasterLock.lock()
        for hostRef in range(1, len(gHost_RowStatus)):
            Configurator.perHostResourceManagementProcesses.append(Process(target = Configurator.startAllConfiguratorThreads, \
                                                                      name = gHost_Name[hostRef] + " control process" , \
                                                                      args = [hostRef,]))
            Configurator.perHostResourceManagementProcesses[-1].start()
        MasterLock.unlock()
        
    def startAllConfiguratorThreads(hostRef):
    
        #
        # We are a process on each host so make all the necessary control threada (per host)
        #
        MasterLock.lock()
        # Start a manage host thread
        Configurator.resourceThreads.append(Thread(target = Configurator.manageHost, \
                                             name = gHost_Name[hostRef], \
                                             args = [hostRef,]))
        Configurator.resourceThreads[-1].start()
        gConnectionsNeededCount[0] += 1

        # Iterate over export FS rows that cite this thread's host
        for exportFSRef in range(len(gExportFS_RowStatus)):
            if gExportFS_gHost_Ref[exportFSRef] == hostRef:
                Configurator.resourceThreads.append(Thread(target = Configurator.manageExportFS, \
                                                     name = gExportFS_Name[exportFSRef], \
                                                     args = [exportFSRef,]))
                Configurator.resourceThreads[-1].start()
                gConnectionsNeededCount[0] += 1

        # Iterate over import FS rows that cite this thread's host
        for importFSRef in range(len(gImportFS_RowStatus)):
            if gImportFS_gHost_Ref[importFSRef] == hostRef:
                Configurator.resourceThreads.append(Thread(target = Configurator.manageImportFS, \
                                                     name = gImportFS_Name[importFSRef], \
                                                     args = [importFSRef,]))
                Configurator.resourceThreads[-1].start()
                gConnectionsNeededCount[0] += 1

        # Iterate over FS user rows that cite this thread's host
        for fsUserRef in range(len(gFSUser_RowStatus)):
            if gFSUser_gHost_Ref[fsUserRef] == hostRef:
                Configurator.resourceThreads.append(Thread(target = Configurator.manageFSUser, \
                                                     name = gFSUser_Name[fsUserRef], \
                                                     args = [fsUserRef,]))
                Configurator.resourceThreads[-1].start()
                gConnectionsNeededCount[0] += 1

        MasterLock.unlock()
        
        time.sleep(1)
        
    def activator():

        def randomTransitionChain(currentState, nextState):
        
            MasterLock.lock()
            for i in range(Configurator.transitionsPerHost):
                hostRef = random.randrange(1, len(gHost_RowStatus))
                if gHost_State[hostRef] == currentState:
                    gHost_State[hostRef] = nextState
            MasterLock.unlock()
            time.sleep(Configurator.secondsPerStateTransition)

            MasterLock.lock()
            for i in range(Configurator.transitionsPerExportFS):
                exportFSRef = random.randrange(len(gExportFS_RowStatus))
                if gExportFS_State[exportFSRef] == currentState:
                    gExportFS_State[exportFSRef] = nextState
            MasterLock.unlock()
            time.sleep(Configurator.secondsPerStateTransition)

            MasterLock.lock()
            for i in range(Configurator.transitionsPerImportFS):
                importFSRef = random.randrange(len(gImportFS_RowStatus))
                if gImportFS_State[importFSRef] == currentState:
                    gImportFS_State[importFSRef] = nextState
            MasterLock.unlock()
            time.sleep(Configurator.secondsPerStateTransition)

            MasterLock.lock()
            for i in range(Configurator.transitionsPerFSUser):
                fsUserRef = random.randrange(len(gFSUser_RowStatus))
                if gFSUser_State[fsUserRef] == currentState:
                    gFSUser_State[fsUserRef] = nextState
            MasterLock.unlock()
            time.sleep(Configurator.secondsPerStateTransition)
            
            return

        while (UI.lastCommand != "exit") or (gAllActive[0] != 0):
        
            if gActivatorState[0] == "Activate randomly":
            
                randomTransitionChain("Inactive", "Activating")

            elif (gActivatorState[0] == "Deactivate randomly") or \
                 (gActivatorState[0] == "Stop all activity"):

                randomTransitionChain("Active", "Deactivating")
                
            elif gActivatorState[0] == "Swap host #2's role":
            
                time.sleep(Configurator.secondsPerStateTransition * 5)
                
                MasterLock.lock()
                
                if gHost_State[2] == "Active":
                
                    # Set host #2 deactivating and
                    gHost_State[2] = "Deactivating"
                
                    # Wait for all its "users" and it to stop
                    while gHost_State[2] != "Inactive":
                        MasterLock.unlock()
                        time.sleep(1)
                        MasterLock.lock()
                        
                    # Leave above locked!
                        
                    # Sleeps are for looks in the UI
                    time.sleep(1)
                    
                    # Force stalled "Activating" resources back to "Inactive"
                    for hostRef in range(len(gHost_RowStatus)):
                        if gHost_State[hostRef] == "Activating":
                            gHost_State[hostRef] = "Inactive"

                    for exportFSRef in range(len(gExportFS_RowStatus)):
                        if gExportFS_State[exportFSRef] == "Activating":
                            gExportFS_State[exportFSRef] = "Inactive"

                    for importFSRef in range(len(gImportFS_RowStatus)):
                        if gImportFS_State[importFSRef] == "Activating":
                            gImportFS_State[importFSRef] = "Inactive"

                    for fsUserRef in range(len(gFSUser_RowStatus)):
                        if gFSUser_State[fsUserRef] == "Activating":
                            gFSUser_State[fsUserRef] = "Inactive"

                    time.sleep(1)

                    if gHost_Role[2] == "Client":
                        gHost_Role[2] = "Server"
                    else:
                        gHost_Role[2] = "Client"
                        
                gActivatorState[0] = "Activate randomly"
                
                MasterLock.unlock()

            elif gActivatorState[0].startswith("Waiting"):

                time.sleep(1)
                
            else:
            
                print (gActivatorState[0])
                x = 1/0     # Invalid activator state                 
                
        return


    #
    # The operations below move the host, export and importfile systems, and the user state machines
    # through the given usage patterns.
    #
    
    # Arrangement of use counts:
    #
    # gHost         (per host)          ExportFSUseCount    ImportFSUseCount    FSUserUseCount
    # gExportFS     (per export)        ImportFSUseCount
    # gImportFS     (per import)        FSUserUseCount
    # gFSUser
    
    # Keep the given host busy as the host type set initially by nfsTest.conf (server or client)
    def manageHost(hostRef):
    
        # Paramiko isn't thread safe so give it its own thread=local storage
        local = threading.local()
        local.hostConnection = None

        while True:
        
            MasterLock.lock()
        
            # If activating a server
            if gHost_Role[hostRef] == "Server":
            
                if gHost_State[hostRef] == "Activating":
            
                    logging.info(f"Activate name = {gHost_Name[hostRef]}; role = {gHost_Role[hostRef]}; state = {gHost_State[hostRef]}")

                    # Make a host connection object once if needed
                    if local.hostConnection is None:
                        local.hostConnection = paramiko.client.SSHClient()
                        local.hostConnection.set_missing_host_key_policy(paramiko.AutoAddPolicy())
                        local.hostConnection.connect(gHost_IP[hostRef], username = gUsername[0], password = gPassword[0])
                        gConnectionsMadeCount[0] += 1
                        time.sleep(0.2)
            
                    gHost_State[hostRef] = "Active"
                    
                # If an active server, do nothing
                elif gHost_State[hostRef] == "Active":
                
                    pass

                # If deactivating a server, first wait for its use counts to go to zero
                elif (gHost_State[hostRef] == "Deactivating") and \
                     (gHost_ExportFSUseCount[hostRef] == 0):

                    logging.info(f"Deactivate name = {gHost_Name[hostRef]}; role = {gHost_Role[hostRef]}; state = {gHost_State[hostRef]}")

                    gHost_State[hostRef] = "Inactive"

                # If unused server, do nothing
                elif (gHost_State[hostRef] == "Inactive"):
                
                    pass

                # If disabling the server just do it
                elif gHost_State[hostRef] == "Disabling":
                
                    gHost_State[hostRef] = "Disabled"
                    
            # If activating a client
            elif gHost_Role[hostRef] == "Client":
            
                if gHost_State[hostRef] == "Activating":
            
                    logging.info(f"Activate name = {gHost_Name[hostRef]}; role = {gHost_Role[hostRef]}; state = {gHost_State[hostRef]}")

                    # Make a host connection object once if needed
                    if local.hostConnection is None:
                        local.hostConnection = paramiko.client.SSHClient()
                        local.hostConnection.set_missing_host_key_policy(paramiko.AutoAddPolicy())
                        local.hostConnection.connect(gHost_IP[hostRef], username = gUsername[0], password = gPassword[0])
                        gConnectionsMadeCount[0] += 1
                        time.sleep(0.2)
            
                    gHost_State[hostRef] = "Active"
                    
                # If an active client, do nothing
                elif gHost_State[hostRef] == "Active":
                
                    pass

                # If deactivating a client, first wait for its use counts to go to zero
                elif (gHost_State[hostRef] == "Deactivating") and \
                     (gHost_ImportFSUseCount[hostRef] == 0) and \
                     (gHost_FSUserUseCount[hostRef] == 0):
                    
                    logging.info(f"Deactivate name = {gHost_Name[hostRef]}; role = {gHost_Role[hostRef]}; state = {gHost_State[hostRef]}")
                    
                    gHost_State[hostRef] = "Inactive"

                # If unused client, do nothing
                elif gHost_State[hostRef] == "Inactive":
                
                    pass

                # If disabling the client, do it and exit thread
                elif gHost_State[hostRef] == "Disabling":
                
                    gHost_State[hostRef] = "Disabled"
                    
            # Unlock to wait in loop
            MasterLock.unlock()
        
            time.sleep(Configurator.secondsPerStateTransition)
        
    # Create and export a FS on the host
    def manageExportFS(exportFSRef):
    
        serverHostRef = gExportFS_gHost_Ref[exportFSRef]

        # Paramiko isn't thread safe so give it its own thread=local storage
        local = threading.local()
        local.hostConnection = None

        def createExportFS():
        
            Configurator.talkToHost(local.hostConnection, serverHostRef, \
                f"echo {gPassword[0]} | sudo -S mkdir -p /var/nfsTest/{gExportFS_Name[exportFSRef]}")
            Configurator.talkToHost(local.hostConnection, serverHostRef, \
                f"echo {gPassword[0]} | sudo -S chown -R nobody:nogroup /var/nfsTest")
                
            Configurator.talkToHost(local.hostConnection, serverHostRef, \
                f"echo {gPassword[0]} | sudo -S ./appendALine /etc/exports '/var/nfsTest/{gExportFS_Name[exportFSRef]} *(rw,sync,no_subtree_check)'")

            Configurator.talkToHost(local.hostConnection, serverHostRef, \
                f"echo {gPassword[0]} | sudo -S systemctl restart nfs-kernel-server")
                
            return

        def destroyExportFS():
        
            Configurator.talkToHost(local.hostConnection, serverHostRef, \
                f"echo {gPassword[0]} | sudo -S ./removeALine /etc/exports '/var/nfsTest/{gExportFS_Name[exportFSRef]} *(rw,sync,no_subtree_check)'")

            Configurator.talkToHost(local.hostConnection, serverHostRef, \
                f"echo {gPassword[0]} | sudo -S systemctl restart nfs-kernel-server")
                
            Configurator.talkToHost(local.hostConnection, serverHostRef, \
                f"echo {gPassword[0]} | sudo -S rm -rf /var/nfsTest/{gExportFS_Name[exportFSRef]}")
                
            return

        # ExportFS actions
        while True:

            MasterLock.lock()

            # If this exported FS belongs to a host that's a server type at this time
            if gHost_Role[serverHostRef] == "Server":
            
                # Directed deactivation of a server host!!
                # If host is being deactivated and the export FS is unused deactivate it
                if (gHost_State[serverHostRef] == "Deactivating") and \
                   (gExportFS_State[exportFSRef] == "Active") and \
                   (gExportFS_ImportFSUseCount[exportFSRef] == 0):
                   
                    if gSMNFSFunctionsEnabled[0]:
                        destroyExportFS()

                    # Track exported FS and backing host
                    gHost_ExportFSUseCount[serverHostRef] -= 1
                    gExportFS_State[exportFSRef] = "Inactive"
                
                # If activating an exported FS and the server is active
                elif (gExportFS_State[exportFSRef] == "Activating") and \
                   (gHost_State[serverHostRef] == "Active"):
               
                    # Make and export the FS
                    logging.info(f"Activate Export FS #{exportFSRef}; host = {gHost_Name[serverHostRef]}; name = {gExportFS_Name[exportFSRef]}; state = {gExportFS_State[exportFSRef]}")
                    
                    # Make a host connection object once if needed
                    if local.hostConnection is None:
                        local.hostConnection = paramiko.client.SSHClient()
                        local.hostConnection.set_missing_host_key_policy(paramiko.AutoAddPolicy())
                        local.hostConnection.connect(gHost_IP[serverHostRef], username = gUsername[0], password = gPassword[0])
                        gConnectionsMadeCount[0] += 1
                        time.sleep(0.2)
            
                    if gSMNFSFunctionsEnabled[0]:
                        createExportFS()

                    # Track exported FS
                    gHost_ExportFSUseCount[serverHostRef] += 1
                    gExportFS_State[exportFSRef] = "Active"
                
                # If managing an active exported FS; do nothing
                elif gExportFS_State[exportFSRef] == "Active":
               
                    # Do nothing
                    pass
                
                # If deactivating an exported FS and its use count is zero
                elif (gExportFS_State[exportFSRef] == "Deactivating") and \
                     (gExportFS_ImportFSUseCount[exportFSRef] == 0):
               
                    # Destroy the exported FS
                    logging.info(f"Deactivate Export FS #{exportFSRef}; name = {gExportFS_Name[exportFSRef]}; state = {gExportFS_State[exportFSRef]}")
                    
                    if gSMNFSFunctionsEnabled[0]:
                        destroyExportFS()

                    # Track exported FS and backing host
                    gHost_ExportFSUseCount[serverHostRef] -= 1
                    gExportFS_State[exportFSRef] = "Inactive"
                
                # If managing an unused exported FS; do nothing
                elif gExportFS_State[exportFSRef] == "Inactive":
               
                    # Do nothing
                    pass

                # If disabling the export FS, do it and exit thread
                elif gExportFS_State[exportFSRef] == "Disabling":
                
                    gExportFS_State[exportFSRef] = "Disabled"
                    
                    # Exit the control thread
                    MasterLock.unlock()

            MasterLock.unlock()
    
            time.sleep(Configurator.secondsPerStateTransition)
                
    def manageImportFS(importFSRef):

        # Get refs of who we are using
        clientHostRef = gImportFS_gHost_Ref[importFSRef]
        exportFSRef = gImportFS_gExportFS_Ref[importFSRef]
        serverHostRef = gExportFS_gHost_Ref[exportFSRef]
    
        # Paramiko isn't thread safe so give it its own thread=local storage
        local = threading.local()
        local.hostConnection = None

        def createImportFS():
        
            Configurator.talkToHost(local.hostConnection, clientHostRef, \
                f"echo {gPassword[0]} | sudo -S mkdir -p /nfsTest/{gImportFS_Name[importFSRef]}")
                
            # Mount the !exported FS! as the !imported FS!
            Configurator.talkToHost(local.hostConnection, clientHostRef, \
                f"echo {gPassword[0]} | sudo -S mount -o actimeo=5 {gHost_IP[gExportFS_gHost_Ref[exportFSRef]]}:/var/nfsTest/{gExportFS_Name[exportFSRef]} /nfsTest/{gImportFS_Name[importFSRef]}")

            Configurator.talkToHost(local.hostConnection, clientHostRef, \
                f"echo {gPassword[0]} | sudo -S ./appendALine /etc/fstab '{gHost_IP[gExportFS_gHost_Ref[exportFSRef]]}:/var/nfsTest/{gExportFS_Name[exportFSRef]}  {gImportFS_Name[importFSRef]}  nfs auto,nofail,noatime,nolock,intr,tcp,actimeo=5 0 0'")

            Configurator.talkToHost(local.hostConnection, clientHostRef, \
                f"echo {gPassword[0]} | sudo -S mkdir -p /var/ioEngine")
                
            return
    
        def destroyImportFS():
        
            # Un-mount the !imported! FS
            Configurator.talkToHost(local.hostConnection, clientHostRef, \
                f"echo {gPassword[0]} | sudo -S umount /nfsTest/{gImportFS_Name[importFSRef]}")

            Configurator.talkToHost(local.hostConnection, clientHostRef, \
                f"echo {gPassword[0]} | sudo -S ./removeALine /etc/fstab '{gHost_IP[gExportFS_gHost_Ref[exportFSRef]]}:/var/nfsTest/{gExportFS_Name[exportFSRef]}  {gImportFS_Name[importFSRef]}'")

            Configurator.talkToHost(local.hostConnection, clientHostRef, \
                f"echo {gPassword[0]} | sudo -S rm -rf /nfsTest/{gImportFS_Name[importFSRef]}")
                
            return
    
        # ImportFS actions
        while True:
        
            MasterLock.lock()
            
            # If this import FS belongs to a host that's a client type at this time
            if gHost_Role[clientHostRef] == "Client":
            
                
                # Directed deactivation of a client or server host!!
                # If deactivating the client or server host and the import FS is active and unused, stop the import FS
                if ((gHost_State[clientHostRef] == "Deactivating") or \
                    (gHost_State[serverHostRef] == "Deactivating")) and \
                   (gImportFS_State[importFSRef] == "Active") and \
                   (gImportFS_FSUserUseCount[importFSRef] == 0):
                   
                    # Unmount an imported FS
                    logging.info(f"Deactivate Import FS #{importFSRef}; name = {gImportFS_Name[importFSRef]}; state = {gImportFS_State[importFSRef]}")
                    
                    if gSMNFSFunctionsEnabled[0]:
                        destroyImportFS()
                    
                    # Track activity of host, export and import FS
                    gExportFS_ImportFSUseCount[exportFSRef] -= 1
                    gHost_ImportFSUseCount[clientHostRef] -= 1
                    gImportFS_State[importFSRef] = "Inactive"
                
                # If activating an import FS and the export is active
                elif (gImportFS_State[importFSRef] == "Activating") and \
                     (gExportFS_State[exportFSRef] == "Active"):
               
                    # Mount an export FS
                    logging.info(f"Activate Import FS #{importFSRef}; name = {gImportFS_Name[importFSRef]}; state = {gImportFS_State[importFSRef]}")
                    
                    # Make a host connection object once if needed
                    if local.hostConnection is None:
                        local.hostConnection = paramiko.client.SSHClient()
                        local.hostConnection.set_missing_host_key_policy(paramiko.AutoAddPolicy())
                        local.hostConnection.connect(gHost_IP[clientHostRef], username = gUsername[0], password = gPassword[0])
                        gConnectionsMadeCount[0] += 1
                        time.sleep(0.2)
            
                    if gSMNFSFunctionsEnabled[0]:
                        createImportFS()

                    # Track activity of host and exported FS
                    gExportFS_ImportFSUseCount[exportFSRef] += 1
                    gHost_ImportFSUseCount[clientHostRef] += 1
                    gImportFS_State[importFSRef] = "Active"
                
                # If managing an active imported FS; do nothing
                elif gImportFS_State[importFSRef] == "Active":
               
                    # Do nothing
                    pass
                
                # If deactivating an unused import FS
                elif (gImportFS_State[importFSRef] == "Deactivating") and \
                     (gImportFS_FSUserUseCount[importFSRef] == 0):
               
                    # Unmount an imported FS
                    logging.info(f"Deactivate Import FS #{importFSRef}; name = {gImportFS_Name[importFSRef]}; state = {gImportFS_State[importFSRef]}")
                    
                    if gSMNFSFunctionsEnabled[0]:
                        destroyImportFS()
                    
                    # Track activity of host and exported FS
                    gExportFS_ImportFSUseCount[exportFSRef] -= 1
                    gHost_ImportFSUseCount[clientHostRef] -= 1
                    gImportFS_State[importFSRef] = "Inactive"
                
                # If managing an unused imported FS; do nothing
                elif gImportFS_State[importFSRef] == "Inactive":
               
                    # Do nothing
                    pass
                
                # If disabling the import FS, do it and exit thread
                elif gImportFS_State[importFSRef] == "Disabling":
                
                    gImportFS_State[importFSRef] = "Disabled"
                    
                    # Exit the control thread
                    MasterLock.unlock()

            MasterLock.unlock()
    
            time.sleep(Configurator.secondsPerStateTransition)
        
    def manageFSUser(fsUserRef):
    
        # Get refs of who we are using from the import FS (we are running on the importing host)
        importFSRef = gFSUser_gImportFS_Ref[fsUserRef]
        exportFSRef = gImportFS_gExportFS_Ref[importFSRef]
        clientHostRef = gImportFS_gHost_Ref[importFSRef]    # The host we are running on
        serverHostRef = gExportFS_gHost_Ref[exportFSRef]    # The host our exported FS is running on
        
        # Paramiko isn't thread safe so give it its own thread=local storage
        local = threading.local()
        local.hostConnection = None

        # FSUser actions
        while True:
        
            MasterLock.lock()

            # If this FS user belongs to a host that's a client type at this time
            if gHost_Role[clientHostRef] == "Client":

                # Directed deactivation of a client or server host!!
                # If deactivating the client host or server host and the FS user is active, stop the FS user
                if ((gHost_State[clientHostRef] == "Deactivating") or \
                    (gHost_State[serverHostRef] == "Deactivating")) and \
                   (gFSUser_State[fsUserRef] == "Active"):
                   
                    # Start no more file system user threads
                    logging.info(f"Deactivate FS user #{fsUserRef}; name = {gFSUser_Name[fsUserRef]}; state = {gFSUser_State[fsUserRef]}")
                    
                    # Track activity
                    gHost_FSUserUseCount[clientHostRef] -= 1
                    gImportFS_FSUserUseCount[importFSRef] -= 1
                    gFSUser_State[fsUserRef] = "Inactive"

                # If creating an FS user and the import is active
                elif (gFSUser_State[fsUserRef] == "Activating") and \
                   (gImportFS_State[importFSRef] == "Active"):

                    # Start a file system user thread
                    logging.info(f"Activate FS user #{fsUserRef}; name = {gFSUser_Name[fsUserRef]}; state = {gFSUser_State[fsUserRef]}")
                    
                    # Make a host connection object once if needed
                    if local.hostConnection is None:
                        local.hostConnection = paramiko.client.SSHClient()
                        local.hostConnection.set_missing_host_key_policy(paramiko.AutoAddPolicy())
                        local.hostConnection.connect(gHost_IP[clientHostRef], username = gUsername[0], password = gPassword[0])
                        gConnectionsMadeCount[0] += 1
                        time.sleep(0.2)
            
                    # Track activity
                    gHost_FSUserUseCount[clientHostRef] += 1
                    gImportFS_FSUserUseCount[importFSRef] += 1
                    gFSUser_State[fsUserRef] = "Active"
                
                # If managing an active FS user start I/O and wait for it to finish
                elif gFSUser_State[fsUserRef] == "Active":
               
                    # Get directory name so we can pull parts of ioEngine file name out
                    destPath = f"/nfsTest/{gImportFS_Name[importFSRef]}/"
                    
                    fileNum = gIOEngineNumber[0]
                    gIOEngineNumber[0] += 1
                    
                    # Do / keep doing I/O with no lock
                    MasterLock.unlock()
                    
                    logging.info(f"Use FS user #{fsUserRef}; name = {gFSUser_Name[fsUserRef]}; state = {gFSUser_State[fsUserRef]}")
                    
                    Configurator.talkToHost(local.hostConnection, clientHostRef, f"echo {gPassword[0]} | sudo -S ./ioEngine --rt=15 {destPath}/0x{fileNum}")
                    
                    MasterLock.lock()
                    
                    gHost_IOCount[clientHostRef] += 1
                
                # If destroying an FS user
                elif (gFSUser_State[fsUserRef] == "Deactivating"):
               
                    # Do nothing else here; import FS will unmount when use count goes to zero
                    logging.info(f"Deactivate FS user #{fsUserRef}; name = {gFSUser_Name[fsUserRef]}; state = {gFSUser_State[fsUserRef]}")
                    
                    # Track activity
                    gHost_FSUserUseCount[clientHostRef] -= 1
                    gImportFS_FSUserUseCount[importFSRef] -= 1
                    gFSUser_State[fsUserRef] = "Inactive"

                # If managing an unused FS user; do nothing
                elif gFSUser_State[fsUserRef] == "Inactive":
               
                    # Do nothing
                    pass
                
                # If disabling the FS user, do it and exit thread
                elif gFSUser_State[fsUserRef] == "Disabling":
                
                    gFSUser_State[fsUserRef] = "Disabled"
                    
                    # Exit the control thread
                    MasterLock.unlock()

            MasterLock.unlock()
    
            time.sleep(Configurator.secondsPerStateTransition)


#
# Routines to handle in-line documentation/text (text in this source file that
#     can be extracted at run time and used for help or templates)
#
if __name__ == "__main__":

    logging.basicConfig(filename = 'nfsTest.log', filemode = "a", \
                        format = '%(asctime)s %(processName)s %(threadName)s %(funcName)s %(lineno)d %(message)s', \
                        encoding = 'utf-8', level = logging.INFO)

    logging.info("")
    logging.info("")
    logging.info("Start nfsTest")

    # Load in this program's code for in-line text processing
    InLineText.getCodeLines()
    
    # Enable NFS operations in the state machines (it can be disabled here for debug)
    gSMNFSFunctionsEnabled[0] = True

    # Set the start time
    gStartTime[0] = time.time()
    
    # Create or process the nfsTest.conf file (this will only return if it already exists)
    Platform.processConfFile()
    
    # Connect to just localhost to start with
    HostComm.connectToHostRefList(hostRefList = (0,))
    
    # Verify pingability to all test hosts from the control host
    Platform.pingAllFromLocalhost()

    # Connect to localhost and all test hosts
    HostComm.connectToHostRefList(hostRefList = range(0, len(gHost_RowStatus)))
    
    # Present the menu and process user input - never return
    UI.coreInteractiveLogic()
        

""" - Help

    This is "Case Study 3" cited by the https://TestingComplexSystems.com web site.
    
    This presents a "test platform" that stands up and runs a number of "NFS" server 
    and client instances through their paces on three or more Linux test hosts. See 
    the "Case Study 3" tab on the above website for more information.

"""